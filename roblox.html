<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Roblox Intelligence Toolkit</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Orbitron:wght@600&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#050612;
  --card:#0b0f1f;
  --accent:#00fff7;
  --accent2:#ff2ed4;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:Inter,system-ui,sans-serif;
  background:
    radial-gradient(circle at 10% 0%,rgba(255,46,212,.18),transparent 45%),
    radial-gradient(circle at 90% 100%,rgba(0,255,247,.25),transparent 45%),
    var(--bg);
  color:#e9faff;
  padding:16px;
}
h1{
  text-align:center;
  font-family:Orbitron,sans-serif;
  margin:6px 0 12px;
}
nav{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  justify-content:center;
  margin-bottom:16px;
}
button{
  border-radius:999px;
  border:1px solid rgba(0,255,255,.4);
  background:#0c1320;
  color:#e9faff;
  padding:8px 14px;
  cursor:pointer;
  font-weight:600;
  font-size:13px;
}
button:hover,button.active{
  background:linear-gradient(135deg,rgba(0,255,255,.3),rgba(255,46,212,.4));
  box-shadow:0 0 18px rgba(0,255,255,.4);
}
input,textarea,select{
  background:#0c1020;
  border:1px solid rgba(0,255,255,.35);
  color:#fff;
  border-radius:10px;
  padding:8px 10px;
}
textarea{width:100%;min-height:120px;resize:vertical}
.controls{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  margin:10px 0;
}
.controls input,.controls select{flex:1;min-width:160px}
.section{
  display:none;
  background:rgba(0,0,0,.3);
  border-radius:14px;
  padding:14px;
  border:1px solid rgba(255,255,255,.08);
  box-shadow:0 18px 50px rgba(0,0,0,.55);
}
.section.active{display:block}
.grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(230px,1fr));
  gap:12px;
  margin-top:10px;
}
.card{
  background:var(--card);
  border-radius:12px;
  padding:12px;
  border:1px solid rgba(0,255,255,.28);
  box-shadow:0 0 18px rgba(0,0,0,.6);
}
.tag{
  display:inline-block;
  padding:2px 10px;
  border-radius:999px;
  font-size:11px;
  border:1px solid rgba(0,255,255,.4);
  color:#9ffcff;
  margin-bottom:4px;
}
#suggestionsList{
  display:none;
  position:absolute;
  background:#050814;
  border:1px solid rgba(0,255,255,.3);
  border-radius:8px;
  margin-top:2px;
  width:100%;
  z-index:30;
  max-height:220px;
  overflow:auto;
}
.suggestion-item{
  padding:6px 8px;
  cursor:pointer;
  font-size:13px;
}
.suggestion-item:hover{background:#141c30}
#loadingOverlay{
  position:fixed;inset:0;
  background:rgba(0,0,0,.55);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:200;
}
.spinner{
  width:60px;height:60px;
  border-radius:50%;
  border:4px solid rgba(0,255,255,.2);
  border-top-color:var(--accent);
  animation:spin .7s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}
#popupOverlay{
  position:fixed;inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:150;
}
.popup{
  background:#050814;
  border-radius:12px;
  border:1px solid rgba(0,255,255,.4);
  padding:12px;
  width:92%;
  max-width:520px;
  max-height:80vh;
  overflow:auto;
}
.popup-item{
  padding:6px 4px;
  border-bottom:1px solid #151a2a;
  font-size:13px;
  cursor:pointer;
}
.popup-item:hover{color:var(--accent)}
table{
  width:100%;
  border-collapse:collapse;
  font-size:13px;
}
th,td{
  border-bottom:1px solid rgba(255,255,255,.06);
  padding:4px 6px;
  text-align:left;
}
.badge-pill{
  display:inline-block;
  padding:2px 8px;
  border-radius:999px;
  font-size:11px;
  margin-right:4px;
}
.badge-ok{background:rgba(0,255,140,.16);border:1px solid rgba(0,255,140,.5)}
.badge-warn{background:rgba(255,180,0,.16);border:1px solid rgba(255,200,0,.6)}
.badge-bad{background:rgba(255,40,100,.16);border:1px solid rgba(255,60,140,.7)}
.outfit-row{display:flex;gap:10px;overflow-x:auto;padding-bottom:6px}
.outfit-card{
  min-width:130px;
  background:#050814;
  border-radius:10px;
  padding:6px;
  border:1px solid rgba(0,255,255,.3);
  text-align:center;
  font-size:12px;
}
.outfit-card img{width:100%;border-radius:8px;display:block}
.small{font-size:12px;opacity:.85}
</style>
</head>
<body>
<h1>ROBLOX INTELLIGENCE TOOLKIT</h1>

<nav>
  <button data-section="profile" class="active">Profile</button>
  <button data-section="badgeboard">Badge Leaderboard</button>
  <button data-section="gametracker">Game Tracker</button>
  <button data-section="alts">Alt Detector</button>
  <button data-section="avatar">Avatar Evolution</button>
</nav>

<!-- PROFILE SECTION -->
<section id="profile" class="section active">
  <h2>Profile / Friends / Groups / Badges</h2>
  <div class="controls" style="position:relative">
    <input id="rbxUser" placeholder="Roblox username">
    <button id="rbxFetch">Fetch Profile</button>
    <div id="suggestionsList"></div>
  </div>
  <div id="rbxResults" class="grid"></div>
</section>

<!-- BADGE LEADERBOARD -->
<section id="badgeboard" class="section">
  <h2>Badge Leaderboard (Custom List)</h2>
  <p class="small">Enter a badge ID and a list of usernames. This checks who owns the badge and sorts them by award date (fastest at top).</p>
  <div class="controls">
    <input id="lbBadgeId" placeholder="Badge ID">
  </div>
  <div class="controls">
    <textarea id="lbUsernames" placeholder="One username per line"></textarea>
  </div>
  <button id="lbScan">Scan List</button>
  <div id="lbResult" style="margin-top:12px"></div>
</section>

<!-- GAME TRACKER -->
<section id="gametracker" class="section">
  <h2>Game Tracker (Place ID ‚Üí Live Stats)</h2>
  <p class="small">Uses Roblox place details + universe API to show name, creator, player count, visits, favorites and votes.</p>
  <div class="controls">
    <input id="gtPlaceId" placeholder="Place ID (e.g. 1818)">
    <button id="gtLoad">Load Game</button>
    <button id="gtRefresh">Refresh</button>
  </div>
  <div id="gtResult" class="card"></div>
</section>

<!-- ALT DETECTOR -->
<section id="alts" class="section">
  <h2>Alt Detector (Advanced)</h2>
  <p class="small">Compares account age, names, description, friends, groups, badges, and avatar assets. This is only an estimate, not proof.</p>
  <div class="controls">
    <input id="altUser1" placeholder="Main username">
    <input id="altUser2" placeholder="Potential alt username">
  </div>
  <button id="altCheck">Compare</button>
  <div id="altResult" style="margin-top:12px"></div>
</section>

<!-- AVATAR EVOLUTION -->
<section id="avatar" class="section">
  <h2>Avatar Evolution (Saved Outfits)</h2>
  <p class="small">Loads saved outfits via avatar API (public via roproxy) and shows thumbnails from Roblox thumbnails API.</p>
  <div class="controls">
    <input id="avUser" placeholder="Username">
    <button id="avLoad">Load Outfits</button>
  </div>
  <div id="avResult" style="margin-top:12px"></div>
</section>

<!-- POPUP -->
<div id="popupOverlay">
  <div class="popup">
    <h3 id="popupTitle"></h3>
    <input id="popupSearch" placeholder="Filter..." style="width:100%;margin-bottom:8px">
    <div id="popupContent"></div>
    <button onclick="closePopup()" style="margin-top:8px">Close</button>
  </div>
</div>

<!-- LOADING -->
<div id="loadingOverlay"><div class="spinner"></div></div>

<script>
// ---------- helpers ----------
const proxyWrap = u => `https://corsproxy.io/?${encodeURIComponent(u)}`;
async function fetchJson(url,opts){
  const res = await fetch(url,{mode:'cors',credentials:'omit',...opts});
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}
async function tryMulti(urls,opts){
  for(const u of urls){
    try{ return await fetchJson(u,opts); }catch{}
  }
  return null;
}

// ---------- section nav ----------
document.querySelectorAll('nav button').forEach(btn=>{
  btn.addEventListener('click',()=>{
    const id = btn.dataset.section;
    document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    document.querySelectorAll('nav button').forEach(b=>b.classList.toggle('active',b===btn));
  });
});

// ---------- popup ----------
const popupOverlay = document.getElementById('popupOverlay');
const popupTitle = document.getElementById('popupTitle');
const popupContent = document.getElementById('popupContent');
const popupSearch = document.getElementById('popupSearch');
let popupItems = [], popupClick = null;
function showPopup(title,items,onClick){
  popupItems = items;
  popupClick = onClick || null;
  popupTitle.textContent = title;
  renderPopup(items);
  popupSearch.value='';
  popupOverlay.style.display='flex';
}
function renderPopup(list){
  popupContent.innerHTML = list.map(v=>`<div class="popup-item" data-v="${v}">${v}</div>`).join('');
  popupContent.querySelectorAll('.popup-item').forEach(el=>{
    el.onclick = ()=>{ if(popupClick) popupClick(el.dataset.v); };
  });
}
popupSearch.oninput = ()=>{
  const q = popupSearch.value.toLowerCase();
  renderPopup(popupItems.filter(v=>v.toLowerCase().includes(q)));
};
function closePopup(){ popupOverlay.style.display='none'; }

// ---------- loading ----------
const loading = document.getElementById('loadingOverlay');
const setLoading = on => loading.style.display = on?'flex':'none';

// ---------- lookup user ----------
const usernameEndpoints = [
  'https://users.roproxy.com/v1/usernames/users',
  'https://users.rprxy.xyz/v1/usernames/users',
  proxyWrap('https://users.roblox.com/v1/usernames/users')
];
async function lookupUser(name){
  const payload = {usernames:[name],excludeBannedUsers:false};
  for(const url of usernameEndpoints){
    try{
      const data = await fetchJson(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
      if(data?.data?.length) return data.data[0];
    }catch{}
  }
  throw new Error('Unable to reach Roblox user services.');
}

// separate: get full profile by id
async function getUserProfile(id){
  return await tryMulti([
    `https://users.roproxy.com/v1/users/${id}`,
    `https://users.rprxy.xyz/v1/users/${id}`,
    proxyWrap(`https://users.roblox.com/v1/users/${id}`)
  ]);
}

// ---------- profile section ----------
const rbxInput = document.getElementById('rbxUser');
const rbxResults = document.getElementById('rbxResults');
const suggList = document.getElementById('suggestionsList');
let suggTimer=null;

rbxInput.oninput = ()=>{
  const q = rbxInput.value.trim();
  if(suggTimer) clearTimeout(suggTimer);
  if(q.length<3){ suggList.style.display='none'; return; }
  suggTimer = setTimeout(()=>searchSuggest(q),220);
};
async function searchSuggest(q){
  try{
    const data = await fetchJson(proxyWrap(`https://users.roblox.com/v1/users/search?keyword=${encodeURIComponent(q)}&limit=10`));
    if(!data?.data?.length){suggList.style.display='none';return;}
    suggList.innerHTML = data.data.map(u=>`<div class="suggestion-item" data-u="${u.name}">${u.displayName} (@${u.name})</div>`).join('');
    suggList.style.display='block';
    suggList.querySelectorAll('.suggestion-item').forEach(el=>{
      el.onclick = ()=>{rbxInput.value=el.dataset.u;suggList.style.display='none';renderProfile(el.dataset.u);};
    });
  }catch{ suggList.style.display='none'; }
}
document.getElementById('rbxFetch').onclick = ()=>renderProfile(rbxInput.value.trim());

async function renderProfile(username){
  if(!username) return;
  rbxResults.innerHTML = `<div class="card">Loading profile for <b>${username}</b>...</div>`;
  setLoading(true);
  try{
    const user = await lookupUser(username);
    const id = user.id;
    const profile = await getUserProfile(id);
    const friends = await tryMulti([
      `https://friends.roproxy.com/v1/users/${id}/friends?limit=200`,
      `https://friends.rprxy.xyz/v1/users/${id}/friends?limit=200`,
      proxyWrap(`https://friends.roblox.com/v1/users/${id}/friends?limit=200`)
    ]);
    const groups = await tryMulti([
      `https://groups.roproxy.com/v2/users/${id}/groups/roles`,
      `https://groups.rprxy.xyz/v2/users/${id}/groups/roles`,
      proxyWrap(`https://groups.roblox.com/v2/users/${id}/groups/roles`)
    ]);
    const badges = await tryMulti([
      `https://badges.roproxy.com/v1/users/${id}/badges?limit=100`,
      `https://badges.rprxy.xyz/v1/users/${id}/badges?limit=100`,
      proxyWrap(`https://badges.roblox.com/v1/users/${id}/badges?limit=100`)
    ]);

    const friendsList = (friends?.data||[]).map(f=>f.name);
    const groupsList = (groups?.data||[]).map(g=>`${g.group.name} ‚Äî ${g.role?.name||'Member'}`);
    const badgeList = (badges?.data||[]).map(b=>b.name);

    rbxResults.innerHTML = '';

    function makeCard(title,body,list,onClickName){
      const c = document.createElement('div');
      c.className='card';
      c.innerHTML = `<h3>${title}</h3><p>${body}</p>`;
      if(list && list.length){
        const btn = document.createElement('button');
        btn.textContent='Show All';
        btn.onclick=()=>showPopup(title,list,onClickName);
        c.appendChild(btn);
      }
      rbxResults.appendChild(c);
    }

    makeCard('Profile',`
      <span class="tag">ID: ${id}</span><br>
      <b>${profile.displayName}</b><br>@${profile.name}<br>
      Created: ${profile.created? new Date(profile.created).toLocaleDateString(): 'Unknown'}<br>
      Description: <span class="small">${profile.description || '(none)'}</span>
    `);
    makeCard('Friends',friendsList.slice(0,6).join(', ')||'None',friendsList,name=>renderProfile(name));
    makeCard('Groups',groupsList.slice(0,5).join('<br>')||'None',groupsList,null);
    if(badgeList.length) makeCard('Badges',badgeList.slice(0,5).join(', '),badgeList,null);

  }catch(err){
    rbxResults.innerHTML = `<div class="card"><h3>Error</h3><p>${err.message}</p></div>`;
  }
  setLoading(false);
}

// ---------- badge leaderboard ----------
document.getElementById('lbScan').onclick = async()=>{
  const badgeId = Number(document.getElementById('lbBadgeId').value.trim());
  const raw = document.getElementById('lbUsernames').value.split(/\r?\n/).map(v=>v.trim()).filter(Boolean);
  const box = document.getElementById('lbResult');
  if(!badgeId || !raw.length){box.innerHTML='<div class="card">Enter badge ID and at least one username.</div>';return;}
  box.innerHTML='<div class="card">Scanning list...</div>';
  setLoading(true);
  const results = [];
  for(const name of raw){
    try{
      const u = await lookupUser(name);
      const id = u.id;
      const data = await tryMulti([
        `https://badges.roproxy.com/v1/users/${id}/badges/awarded-dates?badgeIds=${badgeId}`,
        `https://badges.rprxy.xyz/v1/users/${id}/badges/awarded-dates?badgeIds=${badgeId}`,
        proxyWrap(`https://badges.roblox.com/v1/users/${id}/badges/awarded-dates?badgeIds=${badgeId}`)
      ]);
      const entry = data?.data?.find(x=>String(x.badgeId)===String(badgeId));
      if(entry) results.push({name, id, date:new Date(entry.awardedDate)});
    }catch{}
  }
  setLoading(false);
  if(!results.length){box.innerHTML='<div class="card">None of these users own that badge.</div>';return;}
  results.sort((a,b)=>a.date-b.date);
  let html = `<div class="card"><h3>Owners (${results.length})</h3><table><tr><th>#</th><th>User</th><th>UserId</th><th>Awarded</th></tr>`;
  results.forEach((r,i)=>{
    html += `<tr><td>${i+1}</td><td>${r.name}</td><td>${r.id}</td><td>${r.date.toLocaleString()}</td></tr>`;
  });
  html+='</table></div>';
  box.innerHTML=html;
};

// ---------- game tracker (fixed using multiget-place-details + games API) ----------
let lastGameDetails=null;
document.getElementById('gtLoad').onclick = ()=>loadGameDetails(true);
document.getElementById('gtRefresh').onclick = ()=>loadGameDetails(false);

async function loadGameDetails(reset){
  const placeId = document.getElementById('gtPlaceId').value.trim();
  const box = document.getElementById('gtResult');
  if(!placeId){box.innerHTML='<div class="small">Enter a placeId first.</div>';return;}
  box.innerHTML='<div class="small">Loading place + universe details...</div>';
  setLoading(true);
  try{
    // 1) placeId -> place details (with universeId)
    const placeData = await tryMulti([
      `https://games.roproxy.com/v1/games/multiget-place-details?placeIds=${placeId}`,
      `https://games.rprxy.xyz/v1/games/multiget-place-details?placeIds=${placeId}`,
      proxyWrap(`https://games.roblox.com/v1/games/multiget-place-details?placeIds=${placeId}`)
    ]);
    const place = placeData?.data?.[0];
    if(!place){ throw new Error('Invalid placeId or no data'); }

    const universeId = place.universeId || place.universeId || place.universeId; // redundant but safe

    // 2) universeId -> full game info
    const gameData = await tryMulti([
      `https://games.roproxy.com/v1/games?universeIds=${universeId}`,
      `https://games.rprxy.xyz/v1/games?universeIds=${universeId}`,
      proxyWrap(`https://games.roblox.com/v1/games?universeIds=${universeId}`)
    ]);
    const game = gameData?.data?.[0] || {};

    const name = game.name || place.name || place.Name || 'Unknown';
    const creatorName = game.creator?.name || place.builder || place.Builder || 'Unknown';
    const creatorId = game.creator?.id || place.builderId || place.BuilderId || 'Unknown';
    const playing = game.playing ?? place.playing ?? place.OnlineCount ?? 'Unknown';
    const visits = game.visits ?? place.visits ?? place.VisitedCount ?? 0;
    const favorites = game.favoritedCount ?? place.favoritedCount ?? place.FavoritedCount ?? 0;
    const upVotes = game.upVotes ?? place.TotalUpVotes ?? 0;
    const downVotes = game.downVotes ?? place.TotalDownVotes ?? 0;
    const maxPlayers = game.maxPlayers ?? place.maxPlayers ?? place.MaxPlayers ?? '?';
    const created = game.created || place.created || place.Created;
    const updated = game.updated || place.updated || place.Updated;
    const url = place.url || place.Url || (game.rootPlaceId ? `https://www.roblox.com/games/${game.rootPlaceId}` : '');

    lastGameDetails = {placeId,universeId,game};

    box.innerHTML = `
      <h3>${name}</h3>
      <p>
        <span class="badge-pill badge-ok">UniverseId: ${universeId}</span><br>
        Creator: <b>${creatorName}</b> (id: ${creatorId})<br>
        Max Players: ${maxPlayers}<br>
        Online Now: <b>${playing}</b><br>
        Visits: ${Number(visits).toLocaleString()}<br>
        Favorites: ${Number(favorites).toLocaleString()}<br>
        Votes: üëç ${upVotes} / üëé ${downVotes}<br>
        Created: ${created? new Date(created).toLocaleString():'Unknown'}<br>
        Updated: ${updated? new Date(updated).toLocaleString():'Unknown'}
      </p>
      ${url?`<p class="small">URL: <a href="${url}" target="_blank" style="color:${getComputedStyle(document.body).getPropertyValue('--accent')||'#0ff'}">${url}</a></p>`:''}
    `;
  }catch(err){
    box.innerHTML=`<div class="small">Error loading place: ${err.message}</div>`;
  }
  setLoading(false);
}

// ---------- alt detector (reworked, multi-signal) ----------
function jaccard(a,b){
  const sa = new Set(a), sb = new Set(b);
  let inter=0;
  sa.forEach(v=>{ if(sb.has(v)) inter++; });
  const union = sa.size + sb.size - inter;
  return union? inter/union : 0;
}
function simpleNameSimilarity(a,b){
  a = (a||'').toLowerCase();
  b = (b||'').toLowerCase();
  if(!a || !b) return 0;
  if(a===b) return 1;
  const coreA = a.replace(/\d/g,'');
  const coreB = b.replace(/\d/g,'');
  if(coreA && coreA === coreB) return 0.9;
  let score = 0;
  if(a[0]===b[0]) score += 0.1;
  if(a.slice(0,3)===b.slice(0,3)) score += 0.2;
  if(a.includes(coreB) || b.includes(coreA)) score += 0.2;
  return Math.min(1,score);
}
function descriptionSimilarity(a,b){
  a=(a||'').toLowerCase().trim();
  b=(b||'').toLowerCase().trim();
  if(!a || !b) return 0;
  if(a===b) return 1;
  if(a.length<10 || b.length<10) return 0;
  // crude common substring
  let matches=0;
  const wordsA = a.split(/\s+/);
  const wordsB = new Set(b.split(/\s+/));
  wordsA.forEach(w=>{ if(w.length>3 && wordsB.has(w)) matches++; });
  return Math.min(1, matches/Math.max(3,wordsA.length));
}
function ageSimilarity(t1,t2){
  if(!t1 || !t2) return 0.5;
  const d = Math.abs(new Date(t1).getTime()-new Date(t2).getTime());
  const days = d/(1000*60*60*24);
  if(days<7) return 1;
  if(days<30) return 0.8;
  if(days<90) return 0.6;
  if(days<365) return 0.4;
  if(days<3*365) return 0.2;
  return 0.05;
}

document.getElementById('altCheck').onclick = async()=>{
  const u1 = document.getElementById('altUser1').value.trim();
  const u2 = document.getElementById('altUser2').value.trim();
  const box = document.getElementById('altResult');
  if(!u1||!u2){box.innerHTML='<div class="card">Enter both usernames.</div>';return;}
  box.innerHTML='<div class="card">Fetching deep data...</div>';
  setLoading(true);
  try{
    // basic user objects
    const [raw1,raw2] = await Promise.all([lookupUser(u1),lookupUser(u2)]);
    const [prof1,prof2] = await Promise.all([getUserProfile(raw1.id),getUserProfile(raw2.id)]);

    // friends / groups / badges / avatar assets
    const [g1,g2,f1,f2,b1,b2,av1,av2] = await Promise.all([
      tryMulti([
        `https://groups.roproxy.com/v2/users/${raw1.id}/groups/roles`,
        `https://groups.rprxy.xyz/v2/users/${raw1.id}/groups/roles`,
        proxyWrap(`https://groups.roblox.com/v2/users/${raw1.id}/groups/roles`)
      ]),
      tryMulti([
        `https://groups.roproxy.com/v2/users/${raw2.id}/groups/roles`,
        `https://groups.rprxy.xyz/v2/users/${raw2.id}/groups/roles`,
        proxyWrap(`https://groups.roblox.com/v2/users/${raw2.id}/groups/roles`)
      ]),
      tryMulti([
        `https://friends.roproxy.com/v1/users/${raw1.id}/friends?limit=200`,
        `https://friends.rprxy.xyz/v1/users/${raw1.id}/friends?limit=200`,
        proxyWrap(`https://friends.roblox.com/v1/users/${raw1.id}/friends?limit=200`)
      ]),
      tryMulti([
        `https://friends.roproxy.com/v1/users/${raw2.id}/friends?limit=200`,
        `https://friends.rprxy.xyz/v1/users/${raw2.id}/friends?limit=200`,
        proxyWrap(`https://friends.roblox.com/v1/users/${raw2.id}/friends?limit=200`)
      ]),
      tryMulti([
        `https://badges.roproxy.com/v1/users/${raw1.id}/badges?limit=100`,
        `https://badges.rprxy.xyz/v1/users/${raw1.id}/badges?limit=100`,
        proxyWrap(`https://badges.roblox.com/v1/users/${raw1.id}/badges?limit=100`)
      ]),
      tryMulti([
        `https://badges.roproxy.com/v1/users/${raw2.id}/badges?limit=100`,
        `https://badges.rprxy.xyz/v1/users/${raw2.id}/badges?limit=100`,
        proxyWrap(`https://badges.roblox.com/v1/users/${raw2.id}/badges?limit=100`)
      ]),
      tryMulti([
        `https://avatar.roproxy.com/v1/users/${raw1.id}/avatar`,
        `https://avatar.rprxy.xyz/v1/users/${raw1.id}/avatar`,
        proxyWrap(`https://avatar.roblox.com/v1/users/${raw1.id}/avatar`)
      ]),
      tryMulti([
        `https://avatar.roproxy.com/v1/users/${raw2.id}/avatar`,
        `https://avatar.rprxy.xyz/v1/users/${raw2.id}/avatar`,
        proxyWrap(`https://avatar.roblox.com/v1/users/${raw2.id}/avatar`)
      ])
    ]);

    const groups1=(g1?.data||[]).map(g=>g.group.id);
    const groups2=(g2?.data||[]).map(g=>g.group.id);
    const friends1=(f1?.data||[]).map(f=>f.id);
    const friends2=(f2?.data||[]).map(f=>f.id);
    const badges1=(b1?.data||[]).map(b=>b.id);
    const badges2=(b2?.data||[]).map(b=>b.id);
    const assets1=(av1?.assets||[]).map(a=>a.id);
    const assets2=(av2?.assets||[]).map(a=>a.id);

    const groupScore = jaccard(groups1,groups2);        // social overlap
    const friendScore = jaccard(friends1,friends2);     // direct friend overlap
    const badgeScore = jaccard(badges1,badges2);        // achievement overlap
    const avatarScore = jaccard(assets1,assets2);       // wearing same items
    const nameScore = simpleNameSimilarity(prof1.name,prof2.name);
    const displayScore = simpleNameSimilarity(prof1.displayName,prof2.displayName);
    const descScore = descriptionSimilarity(prof1.description,prof2.description);
    const ageScore = ageSimilarity(prof1.created,prof2.created);

    // weight signals
    const total =
      groupScore * 0.18 +
      friendScore * 0.2 +
      badgeScore * 0.15 +
      avatarScore * 0.22 +
      nameScore * 0.1 +
      displayScore * 0.05 +
      descScore * 0.05 +
      ageScore * 0.05;

    const pct = Math.round(total*100);
    let label='Low';let cls='badge-ok';
    if(pct>=70){label='High';cls='badge-bad';}
    else if(pct>=40){label='Medium';cls='badge-warn';}

    const fmt = v=> (v*100).toFixed(1)+'%';

    box.innerHTML = `
      <div class="card">
        <h3>Estimated Alt Chance: ${pct}% <span class="badge-pill ${cls}">${label}</span></h3>
        <p>
          ${prof1.name} (id: ${raw1.id})<br>
          ${prof2.name} (id: ${raw2.id})
        </p>
        <ul class="small">
          <li>Groups overlap: ${fmt(groupScore)}</li>
          <li>Friends overlap: ${fmt(friendScore)}</li>
          <li>Badges overlap: ${fmt(badgeScore)}</li>
          <li>Avatar item overlap: ${fmt(avatarScore)}</li>
          <li>Username similarity: ${fmt(nameScore)}</li>
          <li>Display name similarity: ${fmt(displayScore)}</li>
          <li>Description similarity: ${fmt(descScore)}</li>
          <li>Account age similarity: ${fmt(ageScore)}</li>
        </ul>
        <p class="small">
          This is only an estimate based on public data.<br>
          It cannot prove alt accounts, but it can highlight suspicious overlaps.
        </p>
      </div>
    `;
  }catch(err){
    box.innerHTML=`<div class="card"><h3>Error</h3><p>${err.message}</p></div>`;
  }
  setLoading(false);
};

// ---------- avatar evolution / outfits ----------
document.getElementById('avLoad').onclick = async()=>{
  const username = document.getElementById('avUser').value.trim();
  const box = document.getElementById('avResult');
  if(!username){box.innerHTML='<div class="card">Enter a username.</div>';return;}
  box.innerHTML='<div class="card">Loading outfits...</div>';
  setLoading(true);
  try{
    const user = await lookupUser(username);
    const id = user.id;
    const outfits = await tryMulti([
      `https://avatar.roproxy.com/v1/users/${id}/outfits?itemsPerPage=50&page=1`,
      proxyWrap(`https://avatar.roblox.com/v1/users/${id}/outfits?itemsPerPage=50&page=1`)
    ]);
    if(!outfits?.data?.length){box.innerHTML='<div class="card">No public outfits found.</div>';setLoading(false);return;}
    const ids = outfits.data.map(o=>o.id).slice(0,50);
    const thumbData = await tryMulti([
      `https://thumbnails.roproxy.com/v1/users/outfits?userOutfitIds=${ids.join(',')}&size=150x150&format=Png&isCircular=false`,
      proxyWrap(`https://thumbnails.roblox.com/v1/users/outfits?userOutfitIds=${ids.join(',')}&size=150x150&format=Png&isCircular=false`)
    ]);
    const mapThumb = {};
    (thumbData?.data||[]).forEach(t=>{mapThumb[t.targetId]=t.imageUrl;});
    let html = `<div class="card"><h3>Outfits for ${username}</h3><div class="outfit-row">`;
    outfits.data.forEach(o=>{
      const url = mapThumb[o.id] || '';
      html += `
        <div class="outfit-card">
          ${url?`<img src="${url}" alt="${o.name}">`:''}
          <div>${o.name}</div>
          <div class="small">Outfit ID: ${o.id}</div>
        </div>
      `;
    });
    html += '</div><p class="small">These are saved outfits ‚Äì basically an avatar evolution list.</p></div>';
    box.innerHTML = html;
  }catch(err){
    box.innerHTML = `<div class="card"><h3>Error</h3><p>${err.message}</p></div>`;
  }
  setLoading(false);
};
</script>
</body>
</html>
