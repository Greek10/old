<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>EcuadorSite82</title>
  <style>
    :root{--bg:#0b0f14;--panel:rgba(255,255,255,0.06);--accent:#7ce7ff}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#07111a, #0b0f14);font-family:Inter,system-ui,Arial}
    canvas{display:block;cursor:none;}
    #overlay{position:fixed;left:0;top:0;pointer-events:none;z-index:10;display:flex;justify-content:flex-start;align-items:flex-start;padding:14px}
    .panel{background:var(--panel);backdrop-filter:blur(4px);color:#e9f9ff;padding:10px 12px;border-radius:10px;pointer-events:auto}
    #leftPanel{max-width:320px}
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "BufferGeometryUtils": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/utils/BufferGeometryUtils.js"
      }
    }
  </script>
</head>
<body>
  <div id="overlay">
    <div id="leftPanel" class="panel">
      <div style="font-weight:700;margin-bottom:6px">3D Environment Demo</div>
      <div class="hint">Use <strong>W A S D</strong> to move relative to view, <strong>Space</strong> to jump, <strong>O/L/I/P</strong> to look up/down/left/right, <strong>X</strong> to toggle this UI.</div>
      <div style="margin-top:8px"><button id="startBtn">Enter Environment</button></div>
      <div style="margin-top:8px;font-size:13px;opacity:0.9">Pointer lock will snap the mouse to the screen for FPS movement.</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { BufferGeometryUtils } from 'BufferGeometryUtils';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x071018);
    scene.fog = new THREE.FogExp2(0x071018, 0.02);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 500);
    camera.position.set(0,1.7,10);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(1);
    renderer.shadowMap.enabled = false;
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xbde0ff, 0x081122, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(-10,20,10);
    scene.add(dir);

    const groundMat = new THREE.MeshStandardMaterial({color:0x1d2b36, roughness:1});
    const groundGeo = new THREE.PlaneGeometry(200,200,10,10);
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Merge simple structures for performance
    const boxMat = new THREE.MeshStandardMaterial({color:0x4b6b7a});
    const boxes = [];
    for(let i=0;i<20;i++){
      const w=1+Math.random()*4,h=1+Math.random()*6,d=1+Math.random()*4;
      const geo = new THREE.BoxGeometry(w,h,d);
      geo.translate((Math.random()-0.5)*100,h/2,(Math.random()-0.5)*100);
      boxes.push(geo);
    }
    const mergedGeo = BufferGeometryUtils.mergeBufferGeometries(boxes, false);
    const structures = new THREE.Mesh(mergedGeo, boxMat);
    scene.add(structures);

    // Platforms
    const platformMat = new THREE.MeshStandardMaterial({color:0xffaa33});
    const platforms = new THREE.Group();
    const platformPositions = [{x:0,y:3,z:0},{x:5,y:6,z:-5},{x:-7,y:9,z:7},{x:10,y:12,z:5}];
    platformPositions.forEach(pos=>{
      const geo = new THREE.BoxGeometry(4,0.5,4);
      const plat = new THREE.Mesh(geo, platformMat);
      plat.position.set(pos.x,pos.y,pos.z);
      platforms.add(plat);
    });
    scene.add(platforms);

    const sky = new THREE.Mesh(new THREE.SphereGeometry(150,8,4), new THREE.MeshBasicMaterial({color:0x071018, side:THREE.BackSide}));
    scene.add(sky);

    let lookState={pitch:0,yaw:0}, lookSensitivity=0.0025;
    const velocity = new THREE.Vector3();
    const move={forward:false,back:false,left:false,right:false,jump:false};

    function onKey(e){
      const down = e.type==='keydown';
      if(e.code==='KeyW') move.forward=down;
      if(e.code==='KeyS') move.back=down;
      if(e.code==='KeyA') move.left=down;
      if(e.code==='KeyD') move.right=down;
      if(e.code==='Space') move.jump=down;
      if(e.code==='KeyO') lookState.pitch-=0.05;
      if(e.code==='KeyL') lookState.pitch+=0.05;
      if(e.code==='KeyI') lookState.yaw-=0.05;
      if(e.code==='KeyP') lookState.yaw+=0.05;
      if(e.code==='KeyX' && down) {
        const panel = document.getElementById('leftPanel');
        panel.style.display = (panel.style.display==='none') ? 'block' : 'none';
      }
    }
    window.addEventListener('keydown',onKey);
    window.addEventListener('keyup',onKey);

    function onMouseMove(e){
      const dx=e.movementX||0,dy=e.movementY||0;
      lookState.yaw -= dx*lookSensitivity;
      lookState.pitch -= dy*lookSensitivity;
      lookState.pitch = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, lookState.pitch));
    }
    window.addEventListener('mousemove',onMouseMove);

    window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});

    const clock = new THREE.Clock();

    function animate(){
      const dt = Math.min(clock.getDelta(),0.05);
      const directionVector = new THREE.Vector3();
      if(move.forward||move.back||move.left||move.right){
        if(move.forward) directionVector.z -=1;
        if(move.back) directionVector.z +=1;
        if(move.left) directionVector.x -=1;
        if(move.right) directionVector.x +=1;
        directionVector.normalize();
        const camQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,lookState.yaw,0,'YXZ'));
        directionVector.applyQuaternion(camQuat);
        const speed =10;
        velocity.x += (directionVector.x*speed-velocity.x)*10*dt;
        velocity.z += (directionVector.z*speed-velocity.z)*10*dt;
      }
      velocity.y -= 9.8*dt;
      if(move.jump&&velocity.y<=0){velocity.y=5;}
      camera.position.addScaledVector(velocity,dt);
      camera.quaternion.setFromEuler(new THREE.Euler(lookState.pitch,lookState.yaw,0,'YXZ'));

      const playerY=camera.position.y; let landed=false;
      platforms.children.forEach(plat=>{
        const px=plat.position.x,pz=plat.position.z,half=2;
        if(camera.position.x>px-half&&camera.position.x<px+half && camera.position.z>pz-half&&camera.position.z<pz+half && velocity.y<=0){
          if(playerY<=plat.position.y+1.7){camera.position.y=plat.position.y+1.7;velocity.y=0;landed=true;}
        }
      });
      if(camera.position.y<=1.7&&!landed){camera.position.y=1.7;velocity.y=0;}

      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }

    document.getElementById('startBtn').addEventListener('click',()=>{
      renderer.domElement.requestPointerLock();
      animate();
    });
  </script>
</body>
</html>
