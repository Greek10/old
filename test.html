<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Just Shapes & Beats â€” Web Version</title>

<style>
    body, html {
        margin:0; padding:0;
        overflow:hidden;
        background: #0d0d0f;
        color:white;
        font-family:Arial, sans-serif;
        user-select:none;
        touch-action:none;
    }
    canvas {
        display:block;
    }
    #healthBar {
        position:absolute; top:10px; left:50%;
        transform:translateX(-50%);
        width:300px; height:25px;
        background:#333; border:2px solid #777;
    }
    #healthFill {
        width:100%; height:100%;
        background:#0f0;
    }

    /* Ability buttons (mobile compatible) */
    .abilityBtn {
        position:absolute;
        bottom:20px;
        width:70px; height:70px;
        border-radius:50%;
        background:#222;
        border:2px solid #666;
        color:white;
        display:flex; align-items:center; justify-content:center;
        font-size:20px; font-weight:bold;
    }
    #btnShield { left:20px; }
    #btnClear { left:110px; }
    #btnRestore { left:200px; }
</style>
</head>
<body>

<div id="healthBar"><div id="healthFill"></div></div>

<!-- Mobile ability buttons -->
<div id="btnShield" class="abilityBtn">1</div>
<div id="btnClear" class="abilityBtn">2</div>
<div id="btnRestore" class="abilityBtn">3</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = innerWidth;
canvas.height = innerHeight;

let shapes = [];
let particles = [];
let lastSpawn = 0;

const player = {
    x: canvas.width/2,
    y: canvas.height/2,
    size: 40,
    vx: 0,
    vy: 0,
    speed: 0.7,
    maxSpeed: 6,
    dashing: false,
    dashTime: 0,
    dashCooldown: 0,
    dashLength: 200,
    health: 100,
    shield: false,
    shieldTime: 0,
};

const abilities = {
    shield: { cd: 45, timer:0 },
    clear: { cd:120, timer:0 },
    restore:{ cd:90, timer:0 }
};

document.addEventListener("keydown", e => {
    if (e.key === "Shift") tryDash();
    if (e.key === "1") useShield();
    if (e.key === "2") useClear();
    if (e.key === "3") useRestore();
});

document.getElementById("btnShield").onclick = useShield;
document.getElementById("btnClear").onclick = useClear;
document.getElementById("btnRestore").onclick = useRestore;

// =========================
//   ENEMY SHAPES (AUTO SHOOT)
// =========================
class Shape {
    constructor(x,y,size,type,color){
        this.x=x; this.y=y;
        this.size=size;
        this.type=type;
        this.color=color;
        this.hp=3;
        this.shootCooldown=0;
    }
    update(){
        this.shootCooldown -= 1;
        if (this.shootCooldown <= 0) {
            this.shoot();
            this.shootCooldown = 120;
        }
    }
    shoot(){
        const count = 8;
        for(let i=0;i<count;i++){
            const angle = (Math.PI*2/count)*i;
            pellets.push(new Pellet(this.x,this.y,Math.cos(angle)*4,Math.sin(angle)*4));
        }
    }
    draw(){
        ctx.fillStyle = this.color;
        if(this.type === "circle"){
            ctx.beginPath();
            ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
            ctx.fill();
        } else {
            ctx.fillRect(this.x-this.size,this.y-this.size,this.size*2,this.size*2);
        }
    }
}

class Pellet {
    constructor(x,y,vx,vy){
        this.x=x; this.y=y;
        this.vx=vx; this.vy=vy;
        this.size=6;
    }
    update(){ this.x+=this.vx; this.y+=this.vy; }
    draw(){
        ctx.fillStyle="#ff4d4d";
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
        ctx.fill();
    }
}

let pellets = [];

// =========================
// PLAYER MOVEMENT (DESKTOP)
// =========================
const keys={};
document.addEventListener("keydown", e => keys[e.key]=true);
document.addEventListener("keyup", e => keys[e.key]=false);

// ==========================
// MOBILE JOYSTICK (NEW)
// ==========================
let joyActive=false;
let joyStartX=0, joyStartY=0;
let joyStickX=0, joyStickY=0;
let joyRadius=70;

canvas.addEventListener("touchstart", e=>{
    const t=e.touches[0];
    joyActive=true;

    joyStartX=t.clientX;
    joyStartY=t.clientY;

    joyStickX=joyStartX;
    joyStickY=joyStartY;
});

canvas.addEventListener("touchmove", e=>{
    if(!joyActive) return;
    const t=e.touches[0];

    let dx=t.clientX-joyStartX;
    let dy=t.clientY-joyStartY;
    const dist=Math.sqrt(dx*dx + dy*dy);

    if(dist > joyRadius){
        const a=Math.atan2(dy,dx);
        dx=Math.cos(a)*joyRadius;
        dy=Math.sin(a)*joyRadius;
    }

    joyStickX = joyStartX + dx;
    joyStickY = joyStartY + dy;

    player.vx = dx / joyRadius;
    player.vy = dy / joyRadius;
});

canvas.addEventListener("touchend", ()=>{
    joyActive=false;
    player.vx=0;
    player.vy=0;
});

function drawJoystick(){
    if(!joyActive) return;

    ctx.beginPath();
    ctx.arc(joyStartX, joyStartY, joyRadius, 0, Math.PI*2);
    ctx.strokeStyle="rgba(255,255,255,0.3)";
    ctx.lineWidth=4;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(joyStickX, joyStickY, 30, 0, Math.PI*2);
    ctx.fillStyle="rgba(255,255,255,0.5)";
    ctx.fill();
}

// =============================
//   ABILITIES
// =============================
function useShield(){
    if(abilities.shield.timer<=0){
        player.shield=true;
        player.shieldTime=300; // 5 sec
        abilities.shield.timer=abilities.shield.cd;
    }
}

function useClear(){
    if(abilities.clear.timer<=0){
        shapes = [];
        pellets = [];
        abilities.clear.timer = abilities.clear.cd;
    }
}

function useRestore(){
    if(abilities.restore.timer<=0){
        player.health = Math.min(100, player.health + 50);
        abilities.restore.timer = abilities.restore.cd;
    }
}

function tryDash(){
    if(player.dashCooldown<=0){
        player.dashing=true;
        player.dashTime = 20;
        player.dashCooldown = 60;
    }
}

// =============================
// GAME LOOP
// =============================
function update(){
    // timers
    for(const a in abilities){
        if(abilities[a].timer>0) abilities[a].timer -= 1/60;
    }

    if(player.shield){
        player.shieldTime--;
        if(player.shieldTime<=0) player.shield=false;
    }

    if(player.dashing){
        player.x += player.vx*player.maxSpeed*3;
        player.y += player.vy*player.maxSpeed*3;
        player.dashTime--;
        if(player.dashTime<=0) player.dashing=false;
    } else {
        if(keys["w"]||keys["ArrowUp"]) player.vy -= player.speed;
        if(keys["s"]||keys["ArrowDown"]) player.vy += player.speed;
        if(keys["a"]||keys["ArrowLeft"]) player.vx -= player.speed;
        if(keys["d"]||keys["ArrowRight"]) player.vx += player.speed;

        player.vx *= 0.8;
        player.vy *= 0.8;

        player.x += player.vx*player.maxSpeed;
        player.y += player.vy*player.maxSpeed;
    }

    // spawn enemies
    if(Date.now()-lastSpawn>1200){
        lastSpawn=Date.now();
        shapes.push(new Shape(
            Math.random()*canvas.width,
            Math.random()*canvas.height,
            25,
            Math.random()>0.5?"circle":"square",
            ["#ff3b3b","#ff6b00","#ff00ff"][Math.floor(Math.random()*3)]
        ));
    }

    shapes.forEach(s=>s.update());
    pellets.forEach(p=>p.update());

    // collisions
    if(!player.shield){
        pellets.forEach(p=>{
            if(Math.hypot(p.x-player.x,p.y-player.y) < player.size){
                player.health -= 1;
            }
        });
    }

    document.getElementById("healthFill").style.width = player.health+"%";
}

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // player
    ctx.fillStyle = player.shield ? "#44f" : "#00f";
    ctx.fillRect(player.x-player.size/2,player.y-player.size/2,player.size,player.size);

    // shapes
    shapes.forEach(s=>s.draw());
    pellets.forEach(p=>p.draw());

    drawJoystick();
}

function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>