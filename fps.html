<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Single-File FPS — Playable in Browser</title>
  <style>
    :root{--bg:#0b0f14;--panel:rgba(255,255,255,0.06);--accent:#7ce7ff}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#07111a, #0b0f14);font-family:Inter,system-ui,Arial}
    canvas{display:block}
    #overlay{
      position:fixed;left:0;right:0;top:0;pointer-events:none;z-index:10;
      display:flex;justify-content:space-between;align-items:flex-start;padding:14px
    }
    .panel{background:var(--panel);backdrop-filter:blur(4px);color:#e9f9ff;padding:10px 12px;border-radius:10px;pointer-events:auto}
    #leftPanel{max-width:320px}
    .hint{opacity:0.9;font-size:13px}
    #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:14px;height:14px;z-index:11;pointer-events:none}
    #crosshair:before,#crosshair:after{content:'';position:absolute;background:var(--accent);border-radius:2px}
    #crosshair:before{left:50%;top:0;width:2px;height:100%;transform:translateX(-50%)}
    #crosshair:after{top:50%;left:0;width:100%;height:2px;transform:translateY(-50%)}
    #startBtn{display:inline-block;padding:8px 12px;border-radius:8px;background:transparent;border:1px solid rgba(124,231,255,0.18);cursor:pointer;color:var(--accent)}
    #hud {position:fixed;right:14px;top:14px;text-align:right}
    #message{position:fixed;left:50%;transform:translateX(-50%);bottom:8vh;background:rgba(0,0,0,0.5);color:#fff;padding:8px 16px;border-radius:8px;font-weight:600}
    #footer{position:fixed;left:14px;bottom:14px;color:#9fb8c6;font-size:12px}
  </style>
</head>
<body>
  <div id="overlay">
    <div id="leftPanel" class="panel">
      <div style="font-weight:700;margin-bottom:6px">Browser FPS demo</div>
      <div class="hint">Controls: <strong>W A S D</strong> to move, <strong>mouse</strong> to look, <strong>Left click</strong> to shoot, <strong>Space</strong> to jump.</div>
      <div style="margin-top:8px"><button id="startBtn">Click to play (Pointer lock)</button></div>
      <div style="margin-top:8px;font-size:13px;opacity:0.9">Tip: this is a single-file demo. Export to GitHub Pages by uploading this file as <code>index.html</code>.</div>
    </div>
    <div id="hud" class="panel">
      <div>Health: <span id="health">100</span></div>
      <div>Ammo: <span id="ammo">30</span></div>
      <div>Score: <span id="score">0</span></div>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="message">Click <strong>Click to play</strong> and then click inside the page to lock pointer.</div>
  <div id="footer">Built with Three.js — single-file — works on desktop browsers</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/PointerLockControls.js';

    // Basic scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050a0f, 0.035);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,1.7,5);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio ? Math.min(window.devicePixelRatio,2) : 1);
    document.body.appendChild(renderer.domElement);

    // Lights
    const hemi = new THREE.HemisphereLight(0xbde0ff, 0x081122, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(-5,10,5);
    scene.add(dir);

    // Ground
    const groundMat = new THREE.MeshStandardMaterial({color:0x1d2b36, roughness:1});
    const groundGeo = new THREE.PlaneGeometry(200,200);
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Walls / boxes (level)
    const boxes = new THREE.Group();
    const boxMat = new THREE.MeshStandardMaterial({color:0x4b6b7a});
    for(let i=0;i<25;i++){
      const w = 1 + Math.random()*3;
      const h = 1+Math.random()*4;
      const d = 1 + Math.random()*3;
      const geo = new THREE.BoxGeometry(w,h,d);
      const m = new THREE.Mesh(geo, boxMat);
      m.position.set((Math.random()-0.5)*60, h/2, (Math.random()-0.5)*60);
      m.castShadow = true;
      m.userData.hp = 5;
      boxes.add(m);
    }
    scene.add(boxes);

    // Enemies
    const enemies = [];
    const enemyGeo = new THREE.SphereGeometry(0.6, 12,12);
    const enemyMat = new THREE.MeshStandardMaterial({color:0xff6b6b});
    function spawnEnemy(){
      const m = new THREE.Mesh(enemyGeo, enemyMat.clone());
      const angle = Math.random()*Math.PI*2;
      const r = 35 + Math.random()*10;
      m.position.set(Math.cos(angle)*r, 0.6, Math.sin(angle)*r);
      m.userData = {hp:10, speed: 0.6 + Math.random()*0.6};
      scene.add(m);
      enemies.push(m);
    }
    for(let i=0;i<6;i++) spawnEnemy();

    // Simple weapon state
    let ammo = 30; const maxAmmo = 30; let score=0; let health = 100;
    const ammoEl = document.getElementById('ammo');
    const scoreEl = document.getElementById('score');
    const healthEl = document.getElementById('health');

    // Controls
    const controls = new PointerLockControls(camera, document.body);
    document.getElementById('startBtn').addEventListener('click', ()=>{
      controls.lock();
    });
    controls.addEventListener('lock', ()=>{
      document.getElementById('message').style.display='none';
    });
    controls.addEventListener('unlock', ()=>{
      document.getElementById('message').style.display='block';
      document.getElementById('message').textContent = 'Pointer unlocked. Click to play again.';
    });

    // Movement physics
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const move = {forward:false,back:false,left:false,right:false,jump:false};
    let canJump = true;

    function onKey(e){
      const down = (e.type==='keydown');
      if(e.code==='KeyW') move.forward=down;
      if(e.code==='KeyS') move.back=down;
      if(e.code==='KeyA') move.left=down;
      if(e.code==='KeyD') move.right=down;
      if(e.code==='Space') { if(down && canJump){ velocity.y += 5; canJump=false; } }
      if(e.code==='KeyR' && down){ ammo = maxAmmo; ammoEl.textContent = ammo; }
    }
    window.addEventListener('keydown', onKey);
    window.addEventListener('keyup', onKey);

    // Shooting (raycast)
    const raycaster = new THREE.Raycaster();
    window.addEventListener('mousedown', (e)=>{
      if(e.button!==0) return;
      if(ammo<=0) { playClick(false); return; }
      ammo--; ammoEl.textContent = ammo;
      playShot();
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const hits = raycaster.intersectObjects([...enemies, ...boxes.children], false);
      if(hits.length>0){
        const hit = hits[0];
        if(enemies.includes(hit.object)){
          hit.object.userData.hp -= 6;
          hit.object.material.emissive = new THREE.Color(0xff0000).multiplyScalar(0.4);
          if(hit.object.userData.hp<=0){
            scene.remove(hit.object);
            const idx = enemies.indexOf(hit.object); if(idx>=0) enemies.splice(idx,1);
            score += 10; scoreEl.textContent = score;
            setTimeout(()=>spawnEnemy(), 1500);
          }
        } else {
          hit.object.userData.hp -= 3;
          hit.object.material.color.offsetHSL(0,0,-0.02);
          if(hit.object.userData.hp<=0){
            boxes.remove(hit.object);
            score += 2; scoreEl.textContent = score;
          }
        }
      }
    });

    // Simple sounds using WebAudio
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playShot(){
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sawtooth'; o.frequency.value = 800; g.gain.value = 0.04;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(); o.stop(audioCtx.currentTime + 0.06);
    }
    function playClick(ok=true){
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='square'; o.frequency.value = ok?600:200; g.gain.value = 0.02;
      o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + 0.08);
    }

    // Resize
    window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });

    // Main loop
    const clock = new THREE.Clock();
    function animate(){
      const dt = Math.min(clock.getDelta(), 0.05);

      // Movement
      direction.set(0,0,0);
      if(move.forward) direction.z -= 1;
      if(move.back) direction.z += 1;
      if(move.left) direction.x -= 1;
      if(move.right) direction.x += 1;
      direction.normalize();

      // transform direction by camera yaw
      const camQuat = camera.quaternion.clone();
      const yOnly = new THREE.Quaternion(); yOnly.setFromAxisAngle(new THREE.Vector3(0,1,0), getYRotation(camera));
      direction.applyQuaternion(yOnly);

      const speed = 8;
      velocity.x += (direction.x * speed - velocity.x) * 10 * dt;
      velocity.z += (direction.z * speed - velocity.z) * 10 * dt;
      velocity.y -= 9.8 * dt; // gravity

      controls.getObject().position.addScaledVector(velocity, dt);

      // simple ground collision
      if(controls.getObject().position.y < 1.7){
        velocity.y = 0; controls.getObject().position.y = 1.7; canJump = true;
      }

      // Enemies: simple chase
      for(const e of enemies){
        const toPlayer = new THREE.Vector3().subVectors(controls.getObject().position, e.position);
        const dist = toPlayer.length();
        if(dist > 1.2){
          toPlayer.normalize(); e.position.addScaledVector(toPlayer, e.userData.speed * dt);
        } else {
          // hit player
          if(Math.random() < 0.02){ health = Math.max(0, health - 6); healthEl.textContent = health; }
        }
        // enemy facing
        e.lookAt(controls.getObject().position.x, e.position.y, controls.getObject().position.z);
        // small bob
        e.position.y = 0.6 + Math.sin(performance.now()/300 + e.id) * 0.05;
      }

      // simple collision with boxes: don't fall through
      // (For performance this is kept simple)
      // Update camera position
      camera.position.copy(controls.getObject().position);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // helper to extract yaw (y-rotation) from camera
    function getYRotation(obj){
      const e = new THREE.Euler().setFromQuaternion(obj.quaternion, 'YXZ');
      return e.y;
    }

    // Attach a dummy object to controls to represent player's position
    const playerObject = new THREE.Object3D(); playerObject.position.copy(camera.position);
    controls.getObject = () => playerObject;

    // Add a simple gun model (2D-ish)
    const gun = new THREE.Group();
    const gbox = new THREE.BoxGeometry(0.12,0.08,0.5);
    const gmat = new THREE.MeshStandardMaterial({color:0x0ff7ff});
    const gmesh = new THREE.Mesh(gbox, gmat); gmesh.position.set(0.3,-0.2,-0.8);
    gun.add(gmesh); scene.add(gun);

    // sync gun to camera
    function updateGun(){
      const camPos = camera.position.clone();
      const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
      const gunPos = camPos.clone().add(camDir.clone().multiplyScalar(0.6)).add(new THREE.Vector3(0,-0.2,0));
      gun.position.lerp(gunPos, 0.4);
      gun.quaternion.slerp(camera.quaternion, 0.4);
    }

    // small HUD updates loop
    setInterval(()=>{
      ammoEl.textContent = ammo;
      scoreEl.textContent = score;
      healthEl.textContent = health;
      if(health<=0){ document.getElementById('message').style.display='block'; document.getElementById('message').textContent='You died — reload the page to try again.'; controls.unlock(); }
    },200);

    // Start the main loop when pointer locked
    controls.addEventListener('lock', ()=>{ clock.start(); (function frame(){ updateGun(); requestAnimationFrame(frame); })(); animate(); });

    // small touches: ambient objects
    const skyGeo = new THREE.SphereGeometry(120, 32, 16);
    const skyMat = new THREE.MeshBasicMaterial({color:0x071018, side:THREE.BackSide});
    const sky = new THREE.Mesh(skyGeo, skyMat); scene.add(sky);

    // tiny helper: mark enemy ids for bob
    enemies.forEach((e,i)=>{ e.id = i; });

    // Performance note: keep it light. This is a demo.
    // Export: save this file as index.html and upload to GitHub Pages.

  </script>
</body>
</html>
