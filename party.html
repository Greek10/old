<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>party.web — 3D Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: radial-gradient(circle at top, #1a1a2e, #050509, #000);
      font-family: system-ui, sans-serif;
      color: #fff;
    }

    canvas { display: block; }

    /* Start Overlay — fixed & clickable */
    #startOverlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(8px);
      pointer-events: auto;
    }

    /* Ending overlay */
    #endingOverlayInner {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 9998;
    }

    #endingOverlayInner.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .card {
      background: rgba(0,0,0,0.55);
      padding: 25px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.1);
      width: 360px;
      text-align: center;
    }

    .btn {
      margin-top: 15px;
      padding: 10px 22px;
      border-radius: 999px;
      background: #ff5c9a;
      color: white;
      font-weight: bold;
      border: none;
      cursor: pointer;
      font-size: 16px;
    }

    .btn:hover {
      filter: brightness(1.1);
    }

    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 12px;
      height: 12px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      opacity: 0.7;
      z-index: 20;
    }

    #crosshair::before,
    #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.8);
    }

    #crosshair::before {
      left: 50%; top: 0;
      width: 2px; height: 12px;
      transform: translateX(-50%);
    }

    #crosshair::after {
      top: 50%; left: 0;
      width: 12px; height: 2px;
      transform: translateY(-50%);
    }

    #hintOverlayText {
      position: fixed;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%);
      padding: 6px 12px;
      background: rgba(0,0,0,0.5);
      border-radius: 8px;
      font-size: 0.75rem;
      z-index: 20;
    }
  </style>
</head>
<body>

  <!-- CLICKABLE START SCREEN -->
  <div id="startOverlay">
    <div class="card" style="pointer-events:auto;">
      <h1><span style="color:#ff5c9a">party</span>.web</h1>
      <p>Walk to the house… or leave.</p>
      <p><strong>Controls:</strong> WASD, Mouse, Shift</p>
      <button id="startButton" class="btn" style="pointer-events:auto;">Enter Party</button>
    </div>
  </div>

  <!-- Crosshair -->
  <div id="crosshair"></div>

  <!-- Hint -->
  <div id="hintOverlayText">Find the house. Maybe the party is inside.</div>

  <!-- Ending Screen -->
  <div id="endingOverlayInner">
    <div class="card">
      <h2 id="endingCardTitle"></h2>
      <p id="endingCardSubtitle"></p>
      <p id="endingDetails"></p>
      <p style="color:#ff5c9a; margin-top:10px;">Press R to restart</p>
    </div>
  </div>

  <!-- 3D SCENE -->
  <script type="module">

    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
    import { PointerLockControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/PointerLockControls.js";

    let camera, scene, renderer, controls;
    let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, sprint=false;

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const clock = new THREE.Clock();
    let ended = false;
    let tixMesh;

    const triggers = [];
    const startPos = new THREE.Vector3(0, 1.7, 18);

    /* UI references */
    const endingOverlayInner = document.getElementById("endingOverlayInner");
    const endingTitle = document.getElementById("endingCardTitle");
    const endingSubtitle = document.getElementById("endingCardSubtitle");
    const endingDetails = document.getElementById("endingDetails");
    const hintText = document.getElementById("hintOverlayText");

    init();
    animate();

    function init() {
      /* Scene setup */
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050509, 0.045);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.copy(startPos);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      /* Lights */
      scene.add(new THREE.AmbientLight(0x8888aa, 0.9));
      const moon = new THREE.DirectionalLight(0x99bbff, 0.8);
      moon.position.set(20,40,10);
      scene.add(moon);

      /* PointerLock Controls */
      controls = new PointerLockControls(camera, document.body);

      // Start button click
      document.getElementById("startButton").addEventListener("click", () => {
        document.getElementById("startOverlay").style.display = "none";

        setTimeout(() => controls.lock(), 80);
      });

      // safety fallback
      document.body.addEventListener("click", () => {
        if (!controls.isLocked && !ended) controls.lock();
      });

      /* Build world */
      createGround(); createHouse(); createTrees();
      createSubject(); createCar(); createTix();
      setupTriggers();

      /* Input handlers */
      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("keyup", onKeyUp);
      window.addEventListener("resize", onResize);
    }

    /* -----------------------------
       WORLD BUILDING FUNCTIONS
    ------------------------------*/

    function createGround(){
      const m = new THREE.Mesh(
        new THREE.PlaneGeometry(80,80),
        new THREE.MeshStandardMaterial({color:0x0b0f16})
      );
      m.rotation.x = -Math.PI/2;
      scene.add(m);
    }

    function createHouse(){
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(16,8,16),
        new THREE.MeshStandardMaterial({color:0x141421})
      );
      body.position.set(0,4,-10);
      scene.add(body);

      const door = new THREE.Mesh(
        new THREE.PlaneGeometry(3,4),
        new THREE.MeshBasicMaterial({color:0xff5c9a, opacity:0.5, transparent:true})
      );
      door.position.set(0,2,-2);
      scene.add(door);

      const light = new THREE.PointLight(0xff99cc, 2, 20);
      light.position.set(0,4,-12);
      scene.add(light);
    }

    function createTrees(){
      const trunkMat = new THREE.MeshStandardMaterial({color:0x382626});
      const leafMat = new THREE.MeshStandardMaterial({color:0x13281c});

      [[-10,-4],[-14,-8],[10,-3],[14,-7]].forEach(([x,z])=>{
        const trunk = new THREE.Mesh(
          new THREE.CylinderGeometry(0.4,0.7,4),
          trunkMat
        );
        trunk.position.set(x,2,z);
        scene.add(trunk);

        const leaves = new THREE.Mesh(
          new THREE.SphereGeometry(2.2),
          leafMat
        );
        leaves.position.set(x,5,z);
        scene.add(leaves);
      });
    }

    function createSubject(){
      const sub = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.8,1.8),
        new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:0.05})
      );
      sub.position.set(-4,2.3,8);
      sub.userData.subject = true;
      scene.add(sub);
    }

    function createCar(){
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(4,1,2),
        new THREE.MeshStandardMaterial({color:0x30353f})
      );
      body.position.set(0,0.6,24);
      scene.add(body);
    }

    function createTix(){
      tixMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.8,0.2,0.5),
        new THREE.MeshStandardMaterial({color:0xffd15c, emissive:0xffd15c})
      );
      tixMesh.position.set(6,0.3,10);
      scene.add(tixMesh);
    }

    /* -----------------------------
        TRIGGERS / ENDINGS
    ------------------------------*/

    function setupTriggers(){
      triggers.push({
        name:"fake_party",
        type:"volume",
        min:new THREE.Vector3(-1.5,0,-1),
        max:new THREE.Vector3(1.5,3,-4.5),
        done:false
      });

      triggers.push({
        name:"inside_house",
        type:"volume",
        min:new THREE.Vector3(-7,0,-6),
        max:new THREE.Vector3(7,5,-20),
        done:false
      });

      triggers.push({
        name:"car",
        type:"volume",
        min:new THREE.Vector3(-2,0,22),
        max:new THREE.Vector3(2,3,27),
        done:false
      });

      triggers.push({
        name:"tix",
        type:"tix",
        radius:1.4,
        done:false
      });
    }

    function triggerEnding(id){
      if (ended) return;
      ended = true;
      controls.unlock();

      let title="", sub="", det="";

      if(id==="fake_party"){
        title="Fake Party";
        sub="That wasn’t a normal room.";
        det="Something inside was watching.";
      }
      else if(id==="inside_house"){
        title="Winner";
        sub="You stepped into the real party.";
        det="But it didn't feel right.";
      }
      else if(id==="car"){
        title="Refusal";
        sub="You chose to go home.";
        det="But something stood where the house once was.";
      }
      else if(id==="tix"){
        title="Tix Ending";
        sub="You touched the forbidden ticket.";
        det="Nostalgia consumes you.";
      }

      endingTitle.textContent = title + " Ending";
      endingSubtitle.textContent = sub;
      endingDetails.textContent = det;

      endingOverlayInner.classList.add("visible");
    }

    function resetGame(){
      ended = false;
      endingOverlayInner.classList.remove("visible");
      camera.position.copy(startPos);
      camera.rotation.set(0,0,0);
      hintText.textContent = "Find the house.";
    }

    /* -----------------------------
           INPUT
    ------------------------------*/

    function onKeyDown(e){
      if(ended && e.code==="KeyR"){ resetGame(); return; }

      switch(e.code){
        case "KeyW": moveForward=true; break;
        case "KeyA": moveLeft=true; break;
        case "KeyS": moveBackward=true; break;
        case "KeyD": moveRight=true; break;
        case "ShiftLeft": sprint=true; break;
      }
    }

    function onKeyUp(e){
      switch(e.code){
        case "KeyW": moveForward=false; break;
        case "KeyA": moveLeft=false; break;
        case "KeyS": moveBackward=false; break;
        case "KeyD": moveRight=false; break;
        case "ShiftLeft": sprint=false; break;
      }
    }

    /* -----------------------------
         TRIGGER CHECKING
    ------------------------------*/

    function checkTriggers(){
      const p = camera.position;

      for(const t of triggers){

        if(t.done) continue;

        if(t.type==="volume"){
          if(
            p.x>=t.min.x && p.x<=t.max.x &&
            p.y>=t.min.y && p.y<=t.max.y &&
            p.z>=t.min.z && p.z<=t.max.z
          ){
            t.done = true;
            triggerEnding(t.name);
            return;
          }
        }

        if(t.type==="tix"){
          if(p.distanceTo(tixMesh.position) <= t.radius){
            t.done = true;
            triggerEnding("tix");
            return;
          }
        }
      }
    }

    /* -----------------------------
             RENDER LOOP
    ------------------------------*/

    function animate(){
      requestAnimationFrame(animate);

      const dt = clock.getDelta();

      if(!ended && controls.isLocked){

        const speed = sprint ? 420 : 260;

        velocity.x -= velocity.x * 8 * dt;
        velocity.z -= velocity.z * 8 * dt;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        if(moveForward || moveBackward) velocity.z -= direction.z * speed * dt;
        if(moveLeft || moveRight) velocity.x -= direction.x * speed * dt;

        controls.moveRight(-velocity.x * dt);
        controls.moveForward(-velocity.z * dt);

        camera.position.y = 1.7;

        checkTriggers();
      }

      renderer.render(scene,camera);
    }

    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

  </script>

</body>
</html>
