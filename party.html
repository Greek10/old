
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>party.exe — lobby breach</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      --bg: #030207;
      --accent: #ff6be6;
      --accent-2: #6ad5ff;
      --warn: #ffd86b;
      --danger: #ff4b5c;
      --text: #f6f3ff;
      --muted: #b6acc7;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Space Grotesk", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at 25% 20%, rgba(255, 107, 230, 0.2), transparent 45%),
                  radial-gradient(circle at 70% 10%, rgba(106, 213, 255, 0.25), transparent 50%),
                  linear-gradient(160deg, #010104, #0a0418 70%, #020205);
      color: var(--text);
      overflow: hidden;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      background: transparent;
    }

    .overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .overlay.scanlines::before,
    .overlay.scanlines::after {
      content: "";
      position: absolute;
      inset: 0;
      opacity: 0.12;
    }

    .overlay.scanlines::before {
      background-image: linear-gradient(rgba(255,255,255,0.15) 1px, transparent 1px);
      background-size: 100% 3px;
    }

    .overlay.scanlines::after {
      background-image: linear-gradient(120deg, rgba(255,107,230,0.07) 0%, transparent 55%);
    }

    .noise-layer {
      position: fixed;
      inset: 0;
      mix-blend-mode: lighten;
      pointer-events: none;
      opacity: 0.1;
    }

    .ui {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: clamp(1rem, 3vw, 2.5rem);
      z-index: 5;
    }

    .ui header {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      justify-content: space-between;
    }

    .logo {
      text-transform: uppercase;
      letter-spacing: 0.3rem;
      font-weight: 700;
    }

    .status {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .pill {
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 999px;
      padding: 0.45rem 1.2rem;
      font-size: 0.85rem;
      letter-spacing: 0.1rem;
      text-transform: uppercase;
      display: inline-flex;
      gap: 0.4rem;
      align-items: center;
    }

    .bottom-row {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .instructions {
      max-width: 540px;
      line-height: 1.5;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .start-btn {
      width: fit-content;
      border: none;
      border-radius: 999px;
      padding: 0.85rem 1.8rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      color: #05010a;
      box-shadow: 0 15px 35px rgba(255, 107, 230, 0.35);
      transition: transform 0.15s ease;
    }

    .start-btn:active {
      transform: scale(0.96);
    }

    .message,
    .fear-meter {
      font-size: 0.95rem;
      letter-spacing: 0.05rem;
    }

    .message {
      color: var(--warn);
    }

    .fear-meter span {
      display: inline-block;
      min-width: 6ch;
      color: var(--danger);
    }

    .jumpscare {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle, rgba(255,0,32,0.85), rgba(0,0,0,0.98));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(2rem, 8vw, 5rem);
      text-transform: uppercase;
      letter-spacing: 0.4rem;
      font-weight: 700;
      color: #fff;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 10;
      text-shadow: 0 0 30px rgba(255,255,255,0.9);
    }

    .jumpscare.active {
      opacity: 1;
    }

    .win-screen {
      position: fixed;
      inset: 0;
      background: rgba(3, 2, 7, 0.95);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 9;
      text-align: center;
      padding: 2rem;
    }

    .win-screen.active {
      display: flex;
    }

    .win-screen h2 {
      font-size: clamp(2rem, 6vw, 3.5rem);
      margin-bottom: 1rem;
      color: var(--accent-2);
    }

    .win-screen p {
      max-width: 420px;
      color: var(--muted);
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <canvas id="noise" class="noise-layer"></canvas>
  <div class="overlay scanlines"></div>
  <div class="ui">
    <header>
      <div class="logo">party.exe // lobby breach</div>
      <div class="status">
        <div class="pill">keys <span id="keyCount">0 / 3</span></div>
        <div class="pill">distance <span id="distance">???</span></div>
        <div class="pill">state <span id="state">idle</span></div>
      </div>
    </header>
    <div class="bottom-row">
      <div class="instructions">
        Navigate the liminal ballroom and collect <strong>3 invitation bands</strong>. Once secured, reach the exit door to force a shutdown.
        The partygoer hunts by scent—keep moving, sprint with <kbd>Shift</kbd>, and avoid the spotlight. <em>Headphones recommended.</em>
      </div>
      <button class="start-btn" id="start">Initiate lobby</button>
      <div class="message" id="message">Awaiting operator input…</div>
      <div class="fear-meter">fear-level <span id="fear">000%</span></div>
    </div>
  </div>
  <div class="jumpscare" id="jumpscare">run!</div>
  <div class="win-screen" id="winScreen">
    <h2>Extraction complete</h2>
    <p>You severed the music feed, slipped past the host, and escaped the neon labyrinth. Reload the lobby to dive back into the nightmare.</p>
  </div>
  <audio id="ambient" src="Blaze.mp3" preload="auto" loop></audio>
  <script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    const noiseCanvas = document.getElementById('noise');
    const noiseCtx = noiseCanvas.getContext('2d');
    const startBtn = document.getElementById('start');
    const messageEl = document.getElementById('message');
    const keyCountEl = document.getElementById('keyCount');
    const stateEl = document.getElementById('state');
    const distanceEl = document.getElementById('distance');
    const fearEl = document.getElementById('fear');
    const jumpscareEl = document.getElementById('jumpscare');
    const winScreen = document.getElementById('winScreen');
    const ambient = document.getElementById('ambient');

    const world = { width: 1900, height: 1200 };
    let lastTime = 0;
    let running = false;
    let gameOver = false;

    const player = {
      x: 240,
      y: world.height - 260,
      radius: 16,
      speed: 220,
      stamina: 1,
      fear: 0
    };

    const enemy = {
      x: world.width - 280,
      y: 220,
      radius: 22,
      speed: 140,
      chaseSpeed: 200,
      state: 'idle',
      jitter: 0
    };

    const exit = { x: world.width - 160, y: 120, radius: 40 };
    const totalKeys = 3;
    const keys = [];
    const balloons = [];
    const trails = [];

    const pressed = new Set();

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      noiseCanvas.width = window.innerWidth;
      noiseCanvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function initWorld() {
      keys.length = 0;
      balloons.length = 0;
      trails.length = 0;
      for (let i = 0; i < totalKeys; i++) {
        keys.push({
          x: rand(200, world.width - 200),
          y: rand(200, world.height - 200),
          collected: false,
          pulse: rand(0, Math.PI * 2)
        });
      }
      for (let i = 0; i < 14; i++) {
        balloons.push({
          x: rand(120, world.width - 120),
          y: rand(120, world.height - 120),
          hue: rand(280, 340),
          float: rand(0, Math.PI * 2)
        });
      }
    }

    function startGame() {
      running = true;
      gameOver = false;
      player.x = 240;
      player.y = world.height - 260;
      player.fear = 0;
      player.stamina = 1;
      enemy.x = world.width - 280;
      enemy.y = 220;
      enemy.state = 'idle';
      keysCollected = 0;
      initWorld();
      winScreen.classList.remove('active');
      messageEl.textContent = 'Collect the bands and avoid the host.';
      stateEl.textContent = 'tracking';
      ambient.volume = 0.5;
      ambient.play().catch(() => {});
      if (!audioStarted) {
        setupAudio();
      }
    }

    startBtn.addEventListener('click', () => {
      if (!running) {
        startGame();
      }
    });

    const keysDown = new Set();
    window.addEventListener('keydown', (e) => {
      keysDown.add(e.key.toLowerCase());
      if (e.key === ' ' && !running) {
        startGame();
      }
    });
    window.addEventListener('keyup', (e) => keysDown.delete(e.key.toLowerCase()));

    let keysCollected = 0;

    function update(dt) {
      if (!running || gameOver) return;
      const move = { x: 0, y: 0 };
      if (keysDown.has('w') || keysDown.has('arrowup')) move.y -= 1;
      if (keysDown.has('s') || keysDown.has('arrowdown')) move.y += 1;
      if (keysDown.has('a') || keysDown.has('arrowleft')) move.x -= 1;
      if (keysDown.has('d') || keysDown.has('arrowright')) move.x += 1;

      let magnitude = Math.hypot(move.x, move.y) || 1;
      move.x /= magnitude;
      move.y /= magnitude;

      const sprinting = keysDown.has('shift') && player.stamina > 0.15;
      const speed = sprinting ? player.speed * 1.4 : player.speed;

      player.x += move.x * speed * dt;
      player.y += move.y * speed * dt;
      player.x = Math.max(player.radius, Math.min(world.width - player.radius, player.x));
      player.y = Math.max(player.radius, Math.min(world.height - player.radius, player.y));

      if (sprinting && (move.x || move.y)) {
        player.stamina = Math.max(0, player.stamina - dt * 0.5);
      } else {
        player.stamina = Math.min(1, player.stamina + dt * 0.25);
      }

      // enemy logic
      const toPlayerX = player.x - enemy.x;
      const toPlayerY = player.y - enemy.y;
      const dist = Math.hypot(toPlayerX, toPlayerY);
      const normalizedX = toPlayerX / (dist || 1);
      const normalizedY = toPlayerY / (dist || 1);
      const detected = dist < 420;
      const enemySpeed = detected ? enemy.chaseSpeed : enemy.speed;
      enemy.state = detected ? 'hunt' : 'patrol';
      enemy.x += normalizedX * enemySpeed * dt;
      enemy.y += normalizedY * enemySpeed * dt;

      distanceEl.textContent = dist.toFixed(0) + 'u';
      stateEl.textContent = enemy.state;

      // fear meter
      const fearDelta = detected ? (1 - Math.min(dist / 420, 1)) * 55 * dt : -15 * dt;
      player.fear = Math.min(100, Math.max(0, player.fear + fearDelta));
      fearEl.textContent = player.fear.toFixed(0).padStart(3, '0') + '%';

      // trails for motion blur
      trails.push({ x: player.x, y: player.y, life: 1 });
      while (trails.length > 25) trails.shift();
      trails.forEach((t) => (t.life -= dt * 0.6));

      // collect keys
      keys.forEach((key) => {
        if (key.collected) return;
        const d = Math.hypot(player.x - key.x, player.y - key.y);
        if (d < player.radius + 24) {
          key.collected = true;
          keysCollected += 1;
          messageEl.textContent = `Band secured (${keysCollected}/${totalKeys})`;
        }
      });
      keyCountEl.textContent = `${keysCollected} / ${totalKeys}`;

      // check exit
      const exitDist = Math.hypot(player.x - exit.x, player.y - exit.y);
      if (exitDist < exit.radius && keysCollected === totalKeys) {
        running = false;
        winScreen.classList.add('active');
        messageEl.textContent = 'Lobby silenced. Breathe.';
      }

      // enemy collision
      if (dist < player.radius + enemy.radius) {
        triggerJumpscare();
      }

      balloons.forEach((balloon) => {
        balloon.float += dt * 0.6;
      });
    }

    function drawBackground(cameraX, cameraY) {
      ctx.save();
      ctx.translate(cameraX, cameraY);
      const gradient = ctx.createLinearGradient(0, 0, world.width, world.height);
      gradient.addColorStop(0, '#050109');
      gradient.addColorStop(1, '#14011f');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, world.width, world.height);

      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
      for (let x = 0; x < world.width; x += 80) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, world.height);
        ctx.stroke();
      }
      for (let y = 0; y < world.height; y += 80) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(world.width, y);
        ctx.stroke();
      }

      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      for (let i = 0; i < world.width; i += 260) {
        ctx.fillRect(i + 40, 0, 30, world.height);
      }

      ctx.strokeStyle = 'rgba(255, 122, 224, 0.4)';
      ctx.lineWidth = 4;
      ctx.strokeRect(80, 80, world.width - 160, world.height - 160);

      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillRect(exit.x - 50, exit.y - 50, 100, 100);
      ctx.restore();
    }

    function drawPlayer(cameraX, cameraY) {
      ctx.save();
      ctx.translate(cameraX, cameraY);
      trails.forEach((trail) => {
        ctx.globalAlpha = Math.max(0, trail.life);
        ctx.fillStyle = 'rgba(255,107,230,0.35)';
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, player.radius * (1 + (1 - trail.life) * 0.5), 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.shadowColor = 'rgba(255,107,230,0.8)';
      ctx.shadowBlur = 25;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawEnemy(cameraX, cameraY) {
      ctx.save();
      ctx.translate(cameraX, cameraY);
      ctx.shadowColor = 'rgba(255,75,92,0.7)';
      ctx.shadowBlur = 35;
      ctx.fillStyle = '#ff4b5c';
      ctx.beginPath();
      ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.font = '600 14px "Space Grotesk"';
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.fillText('host', enemy.x - 18, enemy.y - enemy.radius - 12);
      ctx.restore();
    }

    function drawExit(cameraX, cameraY) {
      ctx.save();
      ctx.translate(cameraX, cameraY);
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 3;
      ctx.strokeRect(exit.x - 40, exit.y - 60, 80, 120);
      ctx.fillStyle = keysCollected === totalKeys ? 'rgba(106,213,255,0.25)' : 'rgba(255,255,255,0.05)';
      ctx.fillRect(exit.x - 40, exit.y - 60, 80, 120);
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillText('exit', exit.x - 17, exit.y + 4);
      ctx.restore();
    }

    function drawKeys(cameraX, cameraY) {
      ctx.save();
      ctx.translate(cameraX, cameraY);
      keys.forEach((key) => {
        if (key.collected) return;
        key.pulse += 0.08;
        const size = 18 + Math.sin(key.pulse) * 4;
        ctx.fillStyle = '#ffe179';
        ctx.shadowColor = '#ffe179';
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.roundRect(key.x - size / 2, key.y - size / 3, size, size / 1.5, 4);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.strokeRect(key.x - size / 2, key.y - size / 3, size, size / 1.5);
      });
      ctx.restore();
    }

    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        const radius = typeof r === 'number' ? r : 4;
        this.beginPath();
        this.moveTo(x + radius, y);
        this.lineTo(x + w - radius, y);
        this.quadraticCurveTo(x + w, y, x + w, y + radius);
        this.lineTo(x + w, y + h - radius);
        this.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        this.lineTo(x + radius, y + h);
        this.quadraticCurveTo(x, y + h, x, y + h - radius);
        this.lineTo(x, y + radius);
        this.quadraticCurveTo(x, y, x + radius, y);
        this.closePath();
        return this;
      };
    }

    function drawBalloons(cameraX, cameraY) {
      ctx.save();
      ctx.translate(cameraX, cameraY);
      balloons.forEach((balloon) => {
        const offset = Math.sin(balloon.float) * 6;
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.beginPath();
        ctx.moveTo(balloon.x, balloon.y);
        ctx.lineTo(balloon.x, balloon.y + 40);
        ctx.stroke();
        ctx.fillStyle = `hsl(${balloon.hue}, 70%, 60%)`;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.ellipse(balloon.x + offset, balloon.y, 18, 26, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });
      ctx.restore();
    }

    function render(time = 0) {
      const dt = (time - lastTime) / 1000;
      lastTime = time;
      update(dt);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cameraX = canvas.width / 2 - player.x;
      const cameraY = canvas.height / 2 - player.y;

      drawBackground(cameraX, cameraY);
      drawBalloons(cameraX, cameraY);
      drawKeys(cameraX, cameraY);
      drawExit(cameraX, cameraY);
      drawEnemy(cameraX, cameraY);
      drawPlayer(cameraX, cameraY);

      requestAnimationFrame(render);
    }

    function updateNoise() {
      const imageData = noiseCtx.createImageData(noiseCanvas.width, noiseCanvas.height);
      for (let i = 0; i < imageData.data.length; i += 4) {
        const value = Math.random() * 255;
        imageData.data[i] = value;
        imageData.data[i + 1] = value;
        imageData.data[i + 2] = value;
        imageData.data[i + 3] = Math.random() * 35;
      }
      noiseCtx.putImageData(imageData, 0, 0);
      requestAnimationFrame(updateNoise);
    }

    function triggerJumpscare() {
      if (gameOver) return;
      gameOver = true;
      running = false;
      jumpscareEl.classList.add('active');
      messageEl.textContent = 'connection lost — host found you';
      playJumpscareSound();
      setTimeout(() => {
        jumpscareEl.classList.remove('active');
      }, 1800);
    }

    let audioCtx;
    let audioStarted = false;

    function setupAudio() {
      if (audioStarted) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      audioStarted = true;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.value = 42;
      gain.gain.value = 0.05;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
    }

    function playJumpscareSound() {
      if (!audioCtx) {
        setupAudio();
      }
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.value = 460;
      gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 1.2);
    }

    updateNoise();
    render();
  </script>
</body>
</html>
