
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chromaflux // Ultimate Arena</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #05060b;
      --fg: #eaf0ff;
      --muted: #8090b5;
      --accent: #7df3ff;
      --accent-2: #ff8cff;
      --accent-3: #7cff81;
    }
    * { box-sizing: border-box; }
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; background: #02030a; color: var(--fg); font-family: 'Space Grotesk', system-ui, -apple-system, sans-serif; }
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(125, 243, 255, 0.12), transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(255, 140, 255, 0.16), transparent 40%),
        radial-gradient(circle at 40% 90%, rgba(124, 255, 129, 0.12), transparent 40%);
      filter: blur(50px);
      z-index: 0;
      pointer-events: none;
    }
    canvas { position: fixed; inset: 0; width: 100%; height: 100%; display: block; z-index: 1; }
    .chrome { position: fixed; inset: 0; pointer-events: none; display: grid; grid-template-columns: 1fr auto; grid-template-rows: auto 1fr auto; padding: 14px; z-index: 2; gap: 12px; }
    .hud, .panel { background: rgba(8, 10, 20, 0.55); border: 1px solid rgba(255, 255, 255, 0.06); box-shadow: 0 20px 50px rgba(0,0,0,0.45); backdrop-filter: blur(10px); border-radius: 14px; }
    .hud { padding: 10px 12px; display: flex; align-items: center; gap: 12px; width: fit-content; }
    .meter { height: 8px; width: 120px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; border: 1px solid rgba(255,255,255,0.05); }
    .meter span { display: block; height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); width: 0%; transition: width 120ms ease; }
    .mini { font-size: 12px; color: var(--muted); }
    .score { font-weight: 700; letter-spacing: 0.08em; }
    .callout { justify-self: end; align-self: start; padding: 10px 12px; min-width: 220px; max-width: 300px; pointer-events: auto; }
    .callout h1 { margin: 0 0 6px 0; font-size: 18px; letter-spacing: 0.12em; text-transform: uppercase; }
    .callout button { width: 100%; background: linear-gradient(120deg, var(--accent), var(--accent-2)); color: #040510; border: none; border-radius: 12px; padding: 10px; font-weight: 700; letter-spacing: 0.06em; cursor: pointer; box-shadow: 0 12px 40px rgba(125, 243, 255, 0.4); transition: transform 0.15s ease, box-shadow 0.15s ease; }
    .callout button:hover { transform: translateY(-1px); box-shadow: 0 14px 46px rgba(125, 243, 255, 0.45); }
    .callout button:active { transform: translateY(0); }
    .controls { grid-column: 1 / span 2; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: space-between; padding: 10px; }
    .control-pill { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 8px 10px; font-size: 12px; color: var(--muted); backdrop-filter: blur(4px); }
    .control-pill span { color: var(--fg); font-weight: 600; }
    .status { display: flex; gap: 8px; font-size: 12px; color: var(--muted); align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--accent); box-shadow: 0 0 12px var(--accent); }
    .music { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px 10px; background: rgba(255,255,255,0.04); border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); pointer-events: auto; }
    .music.off { opacity: 0.5; }
    .footer { justify-self: end; align-self: end; padding: 10px 12px; display: flex; gap: 10px; align-items: center; }
    .chip { padding: 6px 8px; border-radius: 10px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); font-size: 12px; color: var(--muted); }
    @media (max-width: 800px) {
      .chrome { grid-template-columns: 1fr; grid-template-rows: auto auto 1fr auto; }
      .callout { justify-self: stretch; }
      .controls { order: 4; justify-content: center; }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="chrome">
    <div class="hud">
      <div class="dot"></div>
      <div class="score" id="score">SCORE 000000</div>
      <div class="mini" id="combo">COMBO x1</div>
      <div class="meter" aria-label="heat meter"><span id="heatBar"></span></div>
      <div class="mini" id="status">IDLE</div>
    </div>
    <div class="callout panel">
      <h1>CHROMAFLUX</h1>
      <div class="mini">Ten interlocking mechanics, cinematic particles, and adaptive enemies. Hover the edgesâ€”gameplay stays clear.</div>
      <button id="play">ENTER THE ARENA</button>
    </div>
    <div class="controls panel">
      <div class="control-pill"><span>Move</span> WASD</div>
      <div class="control-pill"><span>Fire</span> Hold LMB</div>
      <div class="control-pill"><span>Drift Boost</span> Shift</div>
      <div class="control-pill"><span>Blink</span> E</div>
      <div class="control-pill"><span>Nova</span> Q</div>
      <div class="control-pill"><span>Gravity Wave</span> R</div>
      <div class="control-pill"><span>Chrono Slow</span> F</div>
      <div class="control-pill"><span>Shield</span> Space</div>
      <div class="control-pill"><span>Hack</span> V</div>
      <div class="control-pill"><span>Drone</span> T</div>
    </div>
    <div class="footer">
      <div class="music off" id="musicToggle">ðŸŽµ Synthwave</div>
      <div class="chip" id="wave">WAVE 1</div>
      <div class="chip" id="health">HEALTH 100</div>
    </div>
  </div>
  <audio id="track" src="Blaze.mp3" preload="auto"></audio>
  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let w, h, center; resize();
    window.addEventListener('resize', resize);

    const keys = new Set();
    let mouse = {x: w/2, y: h/2, down: false};
    window.addEventListener('mousemove', e => mouse = {...mouse, x: e.clientX, y: e.clientY});
    window.addEventListener('mousedown', () => mouse.down = true);
    window.addEventListener('mouseup', () => mouse.down = false);
    window.addEventListener('keydown', e => keys.add(e.key.toLowerCase()));
    window.addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    const playBtn = document.getElementById('play');
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const statusEl = document.getElementById('status');
    const heatBar = document.getElementById('heatBar');
    const waveEl = document.getElementById('wave');
    const healthEl = document.getElementById('health');
    const musicBtn = document.getElementById('musicToggle');
    const track = document.getElementById('track');

    let playing = false; let last = performance.now();
    let score = 0; let combo = 1; let comboTimer = 0; let wave = 1;
    let particles = []; let enemies = []; let projectiles = []; let blasts = []; let pickups = [];
    let hacked = [];
    const rng = (min, max) => Math.random() * (max - min) + min;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    const player = {
      pos: {x: w/2, y: h/2}, vel: {x: 0, y: 0}, angle: 0,
      heat: 0, health: 100, cooldown: 0, dash: 0, nova: 0, gravity: 0, slow: 0, shield: 0, hack: 0, drone: true,
      overheat: false,
    };

    const drone = { angle: 0, cooldown: 0 };

    function resize(){
      w = canvas.width = innerWidth * devicePixelRatio;
      h = canvas.height = innerHeight * devicePixelRatio;
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      ctx.scale(devicePixelRatio, devicePixelRatio);
      center = {x: w/2, y: h/2};
    }

    function addParticle(x, y, color, size=4){
      particles.push({x, y, vx: rng(-1,1), vy: rng(-1,1), life: rng(0.6,1.2), size, color});
    }

    function spawnEnemy(){
      const side = Math.random();
      const x = side < 0.5 ? rng(-200, innerWidth+200) : (side < 0.75 ? -120 : innerWidth+120);
      const y = side < 0.5 ? (side < 0.25 ? -120 : innerHeight+120) : rng(-200, innerHeight+200);
      const type = ['charger','shooter','orb','mine','mirror'][Math.floor(Math.random()*5)];
      enemies.push({x, y, vx: 0, vy: 0, hp: type==='mine'?20:40, type, t: 0});
    }

    function fireProjectile(angle, speed, friendly=true, origin=player.pos){
      const spd = speed || 12;
      projectiles.push({x: origin.x, y: origin.y, vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd, friendly, life: 2, dmg: 15});
    }

    function addScore(v){
      score += Math.floor(v * combo);
      combo = Math.min(combo + 0.05, 10);
      comboTimer = 2.5;
      scoreEl.textContent = `SCORE ${score.toString().padStart(6,'0')}`;
      comboEl.textContent = `COMBO x${combo.toFixed(1)}`;
    }

    function damagePlayer(v){
      if(player.shield > 0) v *= 0.4;
      player.health -= v;
      healthEl.textContent = `HEALTH ${Math.max(0, Math.floor(player.health))}`;
      statusEl.textContent = 'HIT';
      if(player.health <= 0) { playing=false; statusEl.textContent='DOWN'; }
    }

    function update(dt){
      if(!playing) return;
      comboTimer -= dt; if(comboTimer <= 0) combo = Math.max(1, combo - dt*0.5);
      comboEl.textContent = `COMBO x${combo.toFixed(1)}`;

      // Input
      const acc = {x:0,y:0};
      if(keys.has('w')) acc.y -= 1;
      if(keys.has('s')) acc.y += 1;
      if(keys.has('a')) acc.x -= 1;
      if(keys.has('d')) acc.x += 1;
      const mag = Math.hypot(acc.x, acc.y)||1;
      acc.x/=mag; acc.y/=mag;
      const boost = keys.has('shift') ? 1.8 : 1;
      player.vel.x += acc.x * 500 * dt * boost;
      player.vel.y += acc.y * 500 * dt * boost;
      if(keys.has(' ')) player.shield = clamp(player.shield + dt, 0, 2); else player.shield = Math.max(0, player.shield - dt*1.5);
      player.vel.x *= 0.9; player.vel.y *= 0.9;
      player.pos.x = clamp(player.pos.x + player.vel.x*dt, 20, innerWidth-20);
      player.pos.y = clamp(player.pos.y + player.vel.y*dt, 20, innerHeight-20);
      player.angle = Math.atan2(mouse.y - player.pos.y, mouse.x - player.pos.x);

      // Mechanics
      // Blink
      if(keys.has('e') && player.dash<=0){
        player.dash = 3; // cooldown
        player.pos.x += Math.cos(player.angle)*120;
        player.pos.y += Math.sin(player.angle)*120;
        addParticle(player.pos.x, player.pos.y, 'rgba(125,243,255,0.9)', 10);
      }
      player.dash = Math.max(0, player.dash - dt);
      // Nova
      if(keys.has('q') && player.nova<=0){
        player.nova = 4;
        blasts.push({x: player.pos.x, y: player.pos.y, r: 10, max: 160, dmg: 30});
      }
      player.nova = Math.max(0, player.nova - dt);
      // Gravity wave
      if(keys.has('r') && player.gravity<=0){
        player.gravity = 5;
        blasts.push({x: player.pos.x, y: player.pos.y, r: 20, max: 220, dmg: 10, grav:true});
      }
      player.gravity = Math.max(0, player.gravity - dt);
      // Chrono slow
      if(keys.has('f') && player.slow<=0){ player.slow=6; slowTime=2.2; }
      player.slow=Math.max(0, player.slow-dt);
      // Hack
      if(keys.has('v') && player.hack<=0){ player.hack=8; hackNearest(); }
      player.hack=Math.max(0, player.hack-dt);
      // Drone toggle
      if(keys.has('t')) player.drone=true;

      // Heat
      const firing = mouse.down && !player.overheat;
      if(firing){ fireTick += dt; if(fireTick > 0.1){ fireTick=0; fireProjectile(player.angle + rng(-0.05,0.05), 14); addParticle(player.pos.x, player.pos.y, 'rgba(255,140,255,0.5)',3);} }
      player.heat += (firing?20:0) * dt + (boost>1?14:0)*dt;
      player.heat = clamp(player.heat - dt*12, 0, 100);
      player.overheat = player.heat >= 100;
      statusEl.textContent = player.overheat ? 'OVERHEATED' : (firing? 'FIRING' : 'IDLE');
      heatBar.style.width = `${(player.heat)}%`;

      // Projectiles
      projectiles = projectiles.filter(p=>{
        p.life -= dt; p.x += p.vx; p.y += p.vy;
        if(p.x< -200||p.x>innerWidth+200||p.y<-200||p.y>innerHeight+200||p.life<=0) return false;
        if(p.friendly){
          for(const e of enemies){
            if(dist(p,e)<20){ e.hp -= p.dmg; addScore(8); addParticle(e.x,e.y,'rgba(255,255,255,0.6)'); return false; }
          }
        } else {
          if(dist(p, player.pos)<18){ damagePlayer(12); return false; }
        }
        return true;
      });

      // Blasts
      blasts = blasts.filter(b=>{
        b.r += 180*dt;
        for(const e of enemies){
          const d = dist(b, e);
          if(d < b.r){ e.hp -= b.dmg; if(b.grav){ e.vx -= (e.x - b.x)*0.6*dt; e.vy -= (e.y - b.y)*0.6*dt; }
          }
        }
        return b.r < b.max;
      });

      // Drone
      drone.angle += dt*1.6;
      const dx = Math.cos(drone.angle)*60; const dy = Math.sin(drone.angle)*60;
      if(player.drone){
        drone.cooldown -= dt;
        if(drone.cooldown<=0){
          drone.cooldown=0.4;
          const target = enemies[0];
          if(target) fireProjectile(Math.atan2(target.y-player.pos.y,target.x-player.pos.x),10,true,{x:player.pos.x+dx,y:player.pos.y+dy});
        }
      }

      // Enemies
      if(enemies.length < 10+wave*2) spawnEnemy();
      enemies = enemies.filter(e=>{
        e.t += dt;
        const ang = Math.atan2(player.pos.y - e.y, player.pos.x - e.x);
        if(e.type==='charger'){ e.vx += Math.cos(ang)*40*dt*wave; e.vy += Math.sin(ang)*40*dt*wave; }
        if(e.type==='shooter'){ if(e.t>2){ e.t=0; projectiles.push({x:e.x,y:e.y,vx:Math.cos(ang)*6,vy:Math.sin(ang)*6,friendly:false,life:3,dmg:12}); } }
        if(e.type==='orb'){ e.vx += Math.cos(ang+Math.sin(e.t))*20*dt; e.vy += Math.sin(ang+Math.cos(e.t))*20*dt; }
        if(e.type==='mine'){ if(e.t>1.8){ blasts.push({x:e.x,y:e.y,r:0,max:160,dmg:20}); return false; } }
        if(e.type==='mirror'){ // reflects
          if(Math.random()<0.01) projectiles.push({x:e.x,y:e.y,vx:Math.cos(ang+Math.PI/2)*8,vy:Math.sin(ang+Math.PI/2)*8,friendly:false,life:2,dmg:10});
        }
        e.vx*=0.99; e.vy*=0.99; e.x+=e.vx*dt*60; e.y+=e.vy*dt*60;
        // collision
        if(dist(e, player.pos) < 22){ damagePlayer(18); e.hp -=20; }
        if(e.hp<=0){ addScore(40); addParticle(e.x,e.y,'rgba(124,255,129,0.9)',10); pickups.push({x:e.x,y:e.y,t:0}); return false; }
        return true;
      });

      // Hacked allies
      hacked = hacked.filter(h=>{
        h.t -= dt; if(h.t<=0) return false;
        h.x += Math.cos(h.a)*120*dt; h.y += Math.sin(h.a)*120*dt;
        if(Math.random()<0.03) projectiles.push({x:h.x,y:h.y,vx:Math.cos(h.a)*10,vy:Math.sin(h.a)*10,friendly:true,life:2,dmg:18});
        return h.x>-50&&h.x<innerWidth+50&&h.y>-50&&h.y<innerHeight+50;
      });

      // Pickups
      pickups = pickups.filter(p=>{
        p.t += dt;
        if(dist(p, player.pos)<24){ player.health = clamp(player.health+8,0,120); addScore(20); healthEl.textContent = `HEALTH ${Math.floor(player.health)}`; return false; }
        return p.t < 6;
      });

      // Wave progression
      if(score / (wave*wave + 1) > 500){ wave++; waveEl.textContent = `WAVE ${wave}`; }
    }

    function hackNearest(){
      let best = null, bd=9999;
      for(const e of enemies){ const d=dist(e, player.pos); if(d<bd){bd=d; best=e;} }
      if(best){ hacked.push({x:best.x,y:best.y,a:Math.atan2(player.pos.y-best.y, player.pos.x-best.x)+Math.PI,t:6}); enemies = enemies.filter(e=>e!==best); addParticle(best.x,best.y,'rgba(125,243,255,0.9)',12); addScore(60); }
    }

    function dist(a,b){ return Math.hypot((a.x||a.pos?.x||0)-b.x, (a.y||a.pos?.y||0)-b.y); }

    let fireTick=0, slowTime=0;
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000) * (slowTime>0?0.5:1);
      last = now; slowTime = Math.max(0, slowTime - dt);
      ctx.clearRect(0,0,innerWidth,innerHeight);
      drawBackground(now);
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function drawBackground(t){
      const grad = ctx.createRadialGradient(innerWidth/2, innerHeight/2, 200, innerWidth/2, innerHeight/2, Math.max(innerWidth, innerHeight));
      grad.addColorStop(0, 'rgba(10,14,26,0.8)');
      grad.addColorStop(1, 'rgba(2,3,10,0.9)');
      ctx.fillStyle = grad; ctx.fillRect(0,0,innerWidth,innerHeight);
      // grid
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.lineWidth = 1;
      const grid = 80; const offset = (t*0.04)%grid;
      for(let x=-offset; x<innerWidth; x+=grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,innerHeight); ctx.stroke(); }
      for(let y=-offset; y<innerHeight; y+=grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(innerWidth,y); ctx.stroke(); }
      ctx.restore();
    }

    function draw(){
      // player
      ctx.save();
      ctx.translate(player.pos.x, player.pos.y);
      ctx.rotate(player.angle);
      const r = 18;
      const body = ctx.createLinearGradient(-r,0,r,0);
      body.addColorStop(0,'#7df3ff'); body.addColorStop(1,'#ff8cff');
      ctx.fillStyle = body;
      ctx.beginPath();
      ctx.moveTo(r,0); ctx.lineTo(-r,-12); ctx.lineTo(-r,12); ctx.closePath();
      ctx.fill();
      if(player.shield>0){ ctx.strokeStyle = `rgba(125,243,255,${player.shield/2})`; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0,0,r+6,0,Math.PI*2); ctx.stroke(); }
      ctx.restore();

      // drone
      if(player.drone){
        ctx.save();
        ctx.translate(player.pos.x + Math.cos(drone.angle)*60, player.pos.y + Math.sin(drone.angle)*60);
        ctx.fillStyle = '#7cff81'; ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // enemies
      enemies.forEach(e=>{
        ctx.save();
        ctx.translate(e.x,e.y);
        ctx.fillStyle = e.type==='mirror'? '#8bd3ff' : (e.type==='mine'? '#ff9c6f' : '#ff6fd8');
        ctx.beginPath(); ctx.arc(0,0,14,0,Math.PI*2); ctx.fill();
        ctx.restore();
      });

      // projectiles
      ctx.save();
      projectiles.forEach(p=>{
        ctx.fillStyle = p.friendly? '#7df3ff' : '#ff9c6f';
        ctx.fillRect(p.x-2,p.y-2,4,4);
      });
      ctx.restore();

      // blasts
      blasts.forEach(b=>{
        ctx.strokeStyle = b.grav? 'rgba(124,255,129,0.4)' : 'rgba(255,140,255,0.35)';
        ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.stroke();
      });

      // pickups
      pickups.forEach(p=>{
        ctx.fillStyle = '#7cff81'; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill();
      });

      // particles
      particles = particles.filter(p=>{
        p.life -= 0.016; p.x += p.vx*4; p.y += p.vy*4;
        if(p.life<=0) return false;
        ctx.fillStyle = p.color; ctx.fillRect(p.x,p.y,p.size,p.size);
        return true;
      });

      // hacked
      hacked.forEach(h=>{
        ctx.fillStyle = '#7df3ff'; ctx.beginPath(); ctx.arc(h.x,h.y,10,0,Math.PI*2); ctx.fill();
      });
    }

    function start(){
      playing = true; score=0; wave=1; enemies=[]; projectiles=[]; pickups=[]; blasts=[]; hacked=[];
      player.pos={x:innerWidth/2,y:innerHeight/2}; player.vel={x:0,y:0}; player.health=100; player.heat=0; player.overheat=false;
      scoreEl.textContent = 'SCORE 000000'; combo=1; comboEl.textContent='COMBO x1'; healthEl.textContent='HEALTH 100'; waveEl.textContent='WAVE 1';
      if(track.paused){ track.volume=0.5; track.loop=true; track.play().then(()=>musicBtn.classList.remove('off')).catch(()=>musicBtn.classList.add('off')); }
    }

    musicBtn.addEventListener('click',()=>{
      if(track.paused){ track.play().then(()=>musicBtn.classList.remove('off')).catch(()=>musicBtn.classList.add('off')); }
      else { track.pause(); musicBtn.classList.add('off'); }
    });

    playBtn.addEventListener('click', start);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
